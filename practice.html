<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <title>Type of Faith MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%93%96%3C/text%3E%3C/svg%3E">
  <link rel="stylesheet" href="shared/nav.css" />
  <style>
    /* ========== Light theme (default) ========== */
    :root {
      --bg: #faf8f5;
      --ink: #111;
      --muted: #555;
      --ok: #0a7a0a;
      --err: #b00020;
      --accent: #8b6b3b;
      --panel: #fff;
      --border: #eee;
      --banner-bg: #fff7e6;
      --link: #1a56db;
      --input-border: #ddd;
      --btn-border: #ccc;
    }

    /* ========== Dark theme overrides ========== */
    :root[data-theme="dark"] {
      --bg: #0f1115;
      --ink: #e6e6e6;
      --muted: #a8a8a8;
      --ok: #6ee7a0;
      --err: #ff6b81;
      --accent: #d7c3a0;
      --panel: #151922;
      --border: #2a2f3a;
      --banner-bg: #1d2430;
      --link: #87b3ff;
      --input-border: #2b3240;
      --btn-border: #3a4252;
    }

    /* ========== Base styles ========== */
    * { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      margin: 24px;
    }

    a { color: var(--link); }

    h2 {
      margin: 8px 0 16px;
      font-weight: 600;
      color: var(--ink);
    }

    /* ========== Controls ========== */
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px;
    }

    select, button, label, input[type="number"] { font-size: 16px; }
    select, button, input[type="number"] { padding: 8px 10px; }

    input[type="number"] {
      width: 80px;
      background: var(--panel);
      color: var(--ink);
      border: 1px solid var(--input-border);
      border-radius: 6px;
    }

    button {
      cursor: pointer;
      border: 1px solid var(--btn-border);
      background: var(--panel);
      color: var(--ink);
      border-radius: 6px;
    }

    button:active { transform: translateY(1px); }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    /* ========== Verse display ========== */
    #meta {
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    #banner {
      font-size: 14px;
      color: var(--accent);
      margin: 6px 0 10px;
      padding: 6px 8px;
      border-radius: 6px;
      background: var(--banner-bg);
      display: none;
    }

    #verse {
      font-size: 20px;
      line-height: 1.6;
      margin-bottom: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      min-height: 3.5em;
    }

    #typed { color: var(--ok); }

    #incorrect {
      color: #fff;
      background: var(--err);
      border-radius: 2px;
      padding: 0 1px;
    }

    .corrected { background: rgba(253, 224, 71, 0.35); border-radius: 2px; }

    #remaining { color: var(--muted); }

    #hiddenMask {
      color: var(--muted);
      font-style: italic;
    }

    .copyline {
      font-size: 12px;
      color: var(--muted);
      margin: 6px 0 8px;
    }

    /* ========== Input field ========== */
    .input-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      margin: 12px 0;
    }
    #input {
      flex: 1;
      font-size: 20px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--input-border);
      background: var(--panel);
      color: var(--ink);
    }
    #submitBtn {
      display: none;
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      background: var(--ok);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.15s, opacity 0.15s;
      white-space: nowrap;
    }
    #submitBtn:hover {
      opacity: 0.9;
      transform: scale(1.02);
    }

    #input.error-state {
      background: color-mix(in srgb, var(--err) 10%, var(--panel));
      border-color: var(--err);
      box-shadow: 0 2px 0 var(--err);
    }

    /* ========== Blind Faith controls ========== */
    .bf-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 8px 0;
    }

    .right { margin-left: auto; }
    .hint { font-size: 12px; color: var(--muted); }

    /* ========== Stats panels ========== */
    .panels {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }

    .stat { font-variant-numeric: tabular-nums; }

    #status { font-size: 14px; color: var(--muted); }
    #result { font-size: 16px; }
    #bestStats { font-size: 14px; }
    #peekCount { font-weight: 600; }

    /* ========== History table ========== */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--border);
    }

    th { background: color-mix(in srgb, var(--panel) 60%, var(--border)); }

    @media (min-width: 1000px) {
      .panels { grid-template-columns: 1fr 1fr; }
    }

    /* ========== Avatar panel ========== */
    .avatar-panel { margin-bottom: 12px; }

    .avatar-grid {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .avatar-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      padding: 6px;
      border-radius: 8px;
      border: 2px solid transparent;
      transition: border-color 0.2s;
    }

    .avatar-option:hover { border-color: var(--accent); }

    .avatar-option.selected {
      border-color: var(--ok);
      background: color-mix(in srgb, var(--ok) 10%, transparent);
    }

    .avatar-option img {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      object-fit: cover;
    }

    .avatar-option span {
      font-size: 11px;
      color: var(--muted);
    }

    .avatar-option.locked {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .avatar-option.locked img {
      filter: grayscale(100%);
    }

    .avatar-option .lock-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      text-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .avatar-option .progress-bar {
      width: 100%;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 2px;
    }

    .avatar-option .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s;
    }

    .avatar-option .progress-text {
      font-size: 9px;
      color: var(--muted);
    }

    /* ========== Race track ========== */
    .race-track {
      margin: 8px 0;
      padding: 6px 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .track-lane {
      position: relative;
      height: 40px;
      background: color-mix(in srgb, var(--border) 50%, transparent);
      border-radius: 20px;
      overflow: hidden;
    }

    .race-avatar {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      left: 0;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
      z-index: 2;
      transition: left 0.3s ease-out;
    }

    .finish-line {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: repeating-linear-gradient(
        to bottom,
        var(--ink) 0px,
        var(--ink) 4px,
        var(--panel) 4px,
        var(--panel) 8px
      );
      border-right: 2px solid var(--ok);
      z-index: 1;
    }

    .race-pct {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      z-index: 3;
      pointer-events: none;
    }

    /* Daily Challenge */
    .daily-challenge {
      background: linear-gradient(135deg, var(--panel) 0%, color-mix(in srgb, var(--accent) 15%, var(--panel)) 100%);
      border: 2px solid var(--accent);
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }
    .daily-challenge .daily-icon {
      font-size: 32px;
    }
    .daily-challenge .daily-info {
      flex: 1;
      min-width: 200px;
    }
    .daily-challenge .daily-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 4px;
    }
    .daily-challenge .daily-verse {
      font-size: 14px;
      color: var(--muted);
    }
    .daily-challenge .daily-best {
      font-size: 13px;
      color: var(--muted);
      margin-top: 4px;
    }
    .daily-challenge .daily-best strong {
      color: var(--ok);
    }
    .daily-challenge button {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.15s, opacity 0.15s;
    }
    .daily-challenge button:hover {
      opacity: 0.9;
      transform: scale(1.02);
    }

    /* ========== Blind Faith feature card ========== */
    .blind-faith-card {
      background: linear-gradient(135deg, var(--panel) 0%, color-mix(in srgb, var(--accent) 10%, var(--panel)) 100%);
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 16px 20px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      transition: border-color 0.3s, box-shadow 0.3s, background 0.3s;
    }
    .blind-faith-card.active {
      border-color: var(--ok);
      box-shadow: 0 0 0 1px var(--ok), 0 2px 12px color-mix(in srgb, var(--ok) 20%, transparent);
      background: linear-gradient(135deg, var(--panel) 0%, color-mix(in srgb, var(--ok) 12%, var(--panel)) 100%);
    }
    .blind-faith-card .bf-icon {
      font-size: 32px;
      opacity: 0.5;
      transition: opacity 0.3s;
    }
    .blind-faith-card.active .bf-icon {
      opacity: 1;
    }
    .blind-faith-card .bf-info {
      flex: 1;
      min-width: 200px;
    }
    .blind-faith-card .bf-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--ink);
      margin-bottom: 2px;
    }
    .blind-faith-card.active .bf-title {
      color: var(--ok);
    }
    .blind-faith-card .bf-subtitle {
      font-size: 13px;
      color: var(--muted);
    }
    .bf-settings {
      display: flex;
      gap: 16px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }
    .bf-setting {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      color: var(--ink);
    }
    .bf-setting input[type="number"] {
      width: 56px;
      font-size: 14px;
      padding: 4px 6px;
      background: var(--panel);
      color: var(--ink);
      border: 1px solid var(--input-border);
      border-radius: 6px;
    }
    .bf-unit {
      font-size: 12px;
      color: var(--muted);
    }
    .bf-toggle-btn {
      padding: 10px 20px;
      font-size: 15px;
      font-weight: 600;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.15s, opacity 0.15s, background 0.3s;
      white-space: nowrap;
    }
    .bf-toggle-btn:hover {
      opacity: 0.9;
      transform: scale(1.02);
    }
    .blind-faith-card.active .bf-toggle-btn {
      background: var(--ok);
    }

    /* User status bar */
    .user-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .user-bar .user-info {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }
    .user-bar .user-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
    }
    .user-bar .user-name {
      font-weight: 600;
    }
    .user-bar .user-stats {
      color: var(--muted);
      font-size: 12px;
    }
    .user-bar button {
      font-size: 13px;
      padding: 6px 12px;
    }
    .user-bar .login-prompt {
      color: var(--muted);
    }

    /* Leaderboard panel */
    .leaderboard-panel {
      margin-top: 12px;
    }
    .leaderboard-panel h4 {
      margin: 0 0 8px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .leaderboard-panel .refresh-btn {
      font-size: 12px;
      padding: 2px 8px;
      background: transparent;
    }

    /* ========== Celebration animations ========== */
    .celebration-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 999;
      overflow: hidden;
    }
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      opacity: 0;
    }
    .confetti.animate {
      animation: confettiFall 3s ease-out forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    .completion-badge {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      font-size: 80px;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
    }
    .completion-badge.show {
      animation: badgeBounce 1.2s ease-out forwards;
    }
    @keyframes badgeBounce {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      40% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
      60% { transform: translate(-50%, -50%) scale(0.9); opacity: 1; }
      80% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }

    .achievement-toast {
      position: fixed;
      top: 80px;
      right: -400px;
      background: linear-gradient(135deg, #ffd700 0%, #ffb347 100%);
      color: #1a1a1a;
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(255, 215, 0, 0.4);
      z-index: 1002;
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
      transition: right 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    .achievement-toast.show {
      right: 24px;
    }
    .achievement-toast img {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 3px solid #fff;
    }
    .achievement-toast .toast-content {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .achievement-toast .toast-title {
      font-size: 12px;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .achievement-toast .toast-name {
      font-size: 16px;
    }

    .wpm-milestone {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, var(--ok) 0%, #4ade80 100%);
      color: #fff;
      padding: 20px 40px;
      border-radius: 16px;
      font-size: 24px;
      font-weight: 700;
      z-index: 1001;
      opacity: 0;
      pointer-events: none;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 200, 100, 0.4);
    }
    .wpm-milestone.show {
      animation: milestonePop 2s ease-out forwards;
    }
    @keyframes milestonePop {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      80% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(0.9); opacity: 0; }
    }

    /* ========== Seasonal theming ========== */
    .seasonal-banner {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-radius: 12px;
      margin-bottom: 16px;
      background: var(--seasonal-banner, var(--banner-bg));
      color: #fff;
      box-shadow: 0 4px 20px var(--seasonal-glow, transparent);
    }
    .seasonal-banner .seasonal-icon {
      font-size: 32px;
    }
    .seasonal-banner .seasonal-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .seasonal-banner .seasonal-text strong {
      font-size: 18px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    .seasonal-banner .seasonal-text span {
      font-size: 13px;
      opacity: 0.9;
    }

    /* Christmas theme accents */
    [data-season="christmas"] .daily-challenge {
      background: linear-gradient(135deg, var(--panel) 0%, rgba(22, 91, 51, 0.15) 50%, rgba(196, 30, 58, 0.15) 100%);
      border-color: #c41e3a;
    }
    [data-season="christmas"] .daily-challenge .daily-title {
      color: #c41e3a;
    }
    [data-season="christmas"] .daily-challenge .daily-icon::after {
      content: 'üéÑ';
    }
    [data-season="christmas"] .daily-challenge .daily-icon {
      font-size: 0;
    }

    /* Easter theme accents */
    [data-season="easter"] .daily-challenge {
      background: linear-gradient(135deg, var(--panel) 0%, rgba(218, 165, 32, 0.15) 100%);
      border-color: #daa520;
    }
    [data-season="easter"] .daily-challenge .daily-title {
      color: #daa520;
    }
    [data-season="easter"] .daily-challenge .daily-icon::after {
      content: '‚úùÔ∏è';
    }
    [data-season="easter"] .daily-challenge .daily-icon {
      font-size: 0;
    }

    /* Snowfall animation for Christmas */
    [data-season="christmas"] .seasonal-banner::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        radial-gradient(circle, #fff 1px, transparent 1px),
        radial-gradient(circle, #fff 1px, transparent 1px);
      background-size: 50px 50px, 30px 30px;
      background-position: 0 0, 25px 25px;
      opacity: 0.15;
      pointer-events: none;
      border-radius: 12px;
    }
    .seasonal-banner {
      position: relative;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script src="shared/data.js"></script>
  <script src="shared/nav.js"></script>
  <script src="shared/theme.js"></script>
  <script src="shared/audio.js"></script>
  <script src="shared/achievements.js"></script>
  <script src="shared/leaderboard.js"></script>
  <script src="shared/seasons.js"></script>

  <!-- Seasonal Banner (dynamically populated) -->
  <div id="seasonalBannerContainer"></div>

  <!-- User Status Bar -->
  <div class="user-bar" id="userBar">
    <div class="user-info" id="userInfo">
      <span class="login-prompt">Loading...</span>
    </div>
  </div>

  <!-- Celebration elements -->
  <div class="celebration-overlay" id="celebrationOverlay"></div>
  <div class="completion-badge" id="completionBadge"></div>
  <div class="wpm-milestone" id="wpmMilestone"></div>
  <div class="achievement-toast" id="achievementToast">
    <img src="" alt="" id="toastAvatar" />
    <div class="toast-content">
      <div class="toast-title">Achievement Unlocked!</div>
      <div class="toast-name" id="toastName"></div>
    </div>
  </div>

  <!-- Daily Challenge -->
  <div class="daily-challenge" id="dailyChallenge">
    <div class="daily-icon">üìÖ</div>
    <div class="daily-info">
      <div class="daily-title">Daily Challenge</div>
      <div class="daily-verse" id="dailyVerse">Loading today's verse...</div>
      <div class="daily-best" id="dailyBest"></div>
    </div>
    <button id="dailyBtn">Start Challenge</button>
  </div>

  <!-- Blind Faith Mode Card -->
  <div class="blind-faith-card" id="blindFaithCard">
    <input type="checkbox" id="blindToggle" style="display:none" />
    <div class="bf-icon">&#128065;</div>
    <div class="bf-info">
      <div class="bf-title">Blind Faith</div>
      <div class="bf-subtitle">Memorize the verse, then type from memory</div>
      <div class="bf-settings" id="bfSettings" style="display:none">
        <label class="bf-setting">
          Preview
          <input id="previewSec" type="number" min="1" max="30" step="1" />
          <span class="bf-unit">sec</span>
        </label>
        <label class="bf-setting">
          Peek
          <input id="peekSec" type="number" min="1" max="10" step="1" />
          <span class="bf-unit">sec</span>
        </label>
      </div>
    </div>
    <button type="button" id="blindFaithToggleBtn" class="bf-toggle-btn">Activate</button>
  </div>

  <div class="controls">
    <label>
      Category:
      <select id="category">
        <option value="all">All</option>
        <option value="anger">Anger</option>
        <option value="anxiety">Anxiety</option>
        <option value="courage">Courage</option>
        <option value="depression">Depression</option>
        <option value="doubt">Doubt</option>
        <option value="faith">Faith</option>
        <option value="fear">Fear</option>
        <option value="forgiveness">Forgiveness</option>
        <option value="healing">Healing</option>
        <option value="hope">Hope</option>
        <option value="jealousy">Jealousy</option>
        <option value="joy">Joy</option>
        <option value="loss">Loss</option>
        <option value="love">Love</option>
        <option value="patience">Patience</option>
        <option value="peace">Peace</option>
        <option value="pride">Pride</option>
        <option value="stress">Stress</option>
        <option value="temptation">Temptation</option>
        <option value="wisdom">Wisdom</option>
      </select>
    </label>

    <label>
      Verse length:
      <select id="length">
        <option value="any">Any</option>
        <option value="short">Short</option>
        <option value="medium">Medium</option>
        <option value="long">Long</option>
      </select>
    </label>

    <label>
      Version:
      <select id="version">
        <option value="WEB" selected>WEB (World English Bible)</option>
        <option value="KJV">KJV (bible-api.com)</option>
        <option value="FBV">FBV (api.bible via proxy)</option>
        <option value="ESV">ESV (Crossway API via proxy)</option>
      </select>
    </label>

    <button id="newVerseBtn" title="Ctrl+M">New Verse</button>
    <button id="restartBtn" title="Restart this verse (Ctrl+R)">Restart</button>
  </div>

  <div id="avatarPanel" class="card avatar-panel">
    <strong>Choose Your Character</strong>
    <div class="avatar-grid" id="avatarGrid"></div>
  </div>

  <h2 id="categoryTitle">All</h2>

  <div id="meta"></div>
  <div id="banner"></div>

  <div id="verse">
    <span id="typed"></span><span id="incorrect"></span><span id="remaining"></span><span id="hiddenMask"></span>
  </div>

  <div class="copyline" id="copyline"></div>

  <div class="bf-controls" id="bfControls" style="display:none;">
    <button id="peekBtn" title="Reveal the verse (Ctrl+P)">Peek Verse</button>
    <span>Peeks used: <span id="peekCount">0</span></span>
    <span class="hint right">Shortcuts: Ctrl+P peek ¬∑ Ctrl+Enter submit ¬∑ Ctrl+R restart ¬∑ Ctrl+M new</span>
  </div>

  <div id="raceTrack" class="race-track">
    <div class="track-lane">
      <img id="raceAvatar" class="race-avatar" src="" alt="avatar" />
      <span id="racePct" class="race-pct">0%</span>
      <div class="finish-line"></div>
    </div>
  </div>

  <div class="input-row">
    <input id="input" placeholder="Start typing the verse here..." autocomplete="off" spellcheck="false" />
    <button id="submitBtn" title="Submit your attempt (Ctrl+Enter)">Submit</button>
  </div>

  <div class="panels">
    <div class="card">
      <strong>Live Metrics</strong>
      <div id="status" class="stat">WPM: 0 ¬∑ Accuracy: 100% ¬∑ Time: 0.0s</div>
    </div>
    <div class="card">
      <strong>Result</strong>
      <div id="result" class="stat">‚Äî</div>
    </div>
    <div class="card" style="grid-column: 1 / -1;">
      <strong>Best of Session</strong>
      <div id="bestStats" class="stat">
        Best WPM: ‚Äî ¬∑ Best Accuracy: ‚Äî ¬∑ Fastest Time: ‚Äî ¬∑ Best Fairness (Blind): ‚Äî
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div style="display:flex; align-items:center; gap:8px;">
      <strong>Session History</strong>
      <button id="exportBtn" class="right" title="Download CSV of attempts">Export CSV</button>
    </div>
    <div style="overflow:auto;">
      <table id="historyTable" aria-label="Session History">
        <thead>
          <tr>
            <th>Time</th>
            <th>Category</th>
            <th>Reference</th>
            <th>Mode</th>
            <th>Peeks</th>
            <th>Secs</th>
            <th>WPM</th>
            <th>Accuracy%</th>
            <th>Fairness%</th>
          </tr>
        </thead>
        <tbody id="historyBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Daily Leaderboard -->
  <div class="card leaderboard-panel" id="leaderboardPanel">
    <h4>
      üìä Today's Leaderboard
      <button class="refresh-btn" id="refreshLeaderboard">Refresh</button>
    </h4>
    <div id="leaderboardContainer">Loading leaderboard...</div>
  </div>

  <script>
    // ========================================
    // Configuration
    // ========================================
    const LENGTH_THRESHOLDS = { shortMax: 110, mediumMax: 230 };
    const DEFAULT_PREVIEW_SECONDS = 10;
    const DEFAULT_PEEK_SECONDS = 5;

    // ========================================
    // Daily Challenge
    // ========================================
    function getTodayDateString() {
      const d = new Date();
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    function seededRandom(seed) {
      // Simple seeded random using date string
      let h = 0;
      for (let i = 0; i < seed.length; i++) {
        h = ((h << 5) - h + seed.charCodeAt(i)) | 0;
      }
      return Math.abs(h);
    }

    function getDailyVerse() {
      const today = getTodayDateString();

      // Check for seasonal verses first
      const season = TofSeasons.getCurrentSeason();
      if (season && season.verses && season.verses.length > 0) {
        const idx = seededRandom(today) % season.verses.length;
        return { ref: season.verses[idx], seasonal: true, season };
      }

      // Default: all verses
      const allRefs = Object.values(VERSE_CATEGORIES).flat();
      const uniqueRefs = [...new Set(allRefs)];
      const idx = seededRandom(today) % uniqueRefs.length;
      return { ref: uniqueRefs[idx], seasonal: false, season: null };
    }

    function getDailyBest() {
      const today = getTodayDateString();
      const key = `tof_daily_${today}`;
      try {
        return JSON.parse(localStorage.getItem(key) || 'null');
      } catch { return null; }
    }

    function saveDailyBest(wpm, accuracy, time) {
      const today = getTodayDateString();
      const key = `tof_daily_${today}`;
      const current = getDailyBest();
      // Save if no record exists or new WPM is higher
      if (!current || wpm > current.wpm) {
        localStorage.setItem(key, JSON.stringify({ wpm, accuracy, time, date: today }));
        return true;
      }
      return false;
    }

    function initDailyChallenge() {
      const daily = getDailyVerse();
      const dailyRef = daily.ref;
      const dailyVerseEl = document.getElementById('dailyVerse');
      const dailyBestEl = document.getElementById('dailyBest');
      const dailyBtn = document.getElementById('dailyBtn');

      const seasonLabel = daily.seasonal ? ` (${daily.season.name})` : '';
      dailyVerseEl.textContent = `Today's verse: ${dailyRef}${seasonLabel}`;

      const best = getDailyBest();
      if (best) {
        dailyBestEl.innerHTML = `Your best today: <strong>${best.wpm} WPM</strong> ¬∑ ${best.accuracy}% accuracy ¬∑ ${best.time}s`;
      } else {
        dailyBestEl.textContent = 'No attempts yet today. Be the first!';
      }

      dailyBtn.addEventListener('click', async () => {
        dailyBtn.disabled = true;
        dailyBtn.textContent = 'Loading...';
        try {
          await loadSpecificVerse(dailyRef, 'WEB');
          state.isDailyChallenge = true;
        } catch (e) {
          console.error('Failed to load daily verse:', e);
        }
        dailyBtn.disabled = false;
        dailyBtn.textContent = 'Start Challenge';
      });
    }

    // ========================================
    // Avatar definitions (now from achievements system)
    // ========================================
    function getAvatars() {
      return TofAchievements.getAllAvatarsWithStatus();
    }

    // ========================================
    // DOM Element References
    // ========================================
    const elements = {
      category: document.getElementById("category"),
      length: document.getElementById("length"),
      version: document.getElementById("version"),
      blindToggle: document.getElementById("blindToggle"),
      blindFaithCard: document.getElementById("blindFaithCard"),
      blindFaithToggleBtn: document.getElementById("blindFaithToggleBtn"),
      bfSettings: document.getElementById("bfSettings"),
      previewSeconds: document.getElementById("previewSec"),
      peekSeconds: document.getElementById("peekSec"),
      categoryTitle: document.getElementById("categoryTitle"),
      newVerseButton: document.getElementById("newVerseBtn"),
      restartButton: document.getElementById("restartBtn"),
      meta: document.getElementById("meta"),
      banner: document.getElementById("banner"),
      typed: document.getElementById("typed"),
      incorrect: document.getElementById("incorrect"),
      remaining: document.getElementById("remaining"),
      hiddenMask: document.getElementById("hiddenMask"),
      input: document.getElementById("input"),
      submitButton: document.getElementById("submitBtn"),
      blindFaithControls: document.getElementById("bfControls"),
      peekButton: document.getElementById("peekBtn"),
      peekCount: document.getElementById("peekCount"),
      status: document.getElementById("status"),
      result: document.getElementById("result"),
      bestStats: document.getElementById("bestStats"),
      exportButton: document.getElementById("exportBtn"),
      historyBody: document.getElementById("historyBody"),
      copyline: document.getElementById("copyline"),
      avatarGrid: document.getElementById("avatarGrid"),
      raceAvatar: document.getElementById("raceAvatar"),
      racePct: document.getElementById("racePct"),
    };

    // ========================================
    // Application State
    // ========================================
    let state = {
      verseText: "",
      reference: "",
      actualCategory: "All",
      hideTimer: null,
      countdownTimer: null,
      peekTimer: null,
      peekCount: 0,
      started: false,
      startTime: 0,
      finished: false,
      totalKeystrokes: 0,
      errorKeystrokes: 0,
      errorPositions: new Set(),
      previousInputValue: "",
      bestWPM: null,
      bestAccuracy: null,
      fastestTime: null,
      bestFairness: null,
      history: [],
      isDailyChallenge: false,
    };

    // ========================================
    // Avatar Functions
    // ========================================
    function getSelectedAvatar() {
      const savedAvatarId = localStorage.getItem("tof_avatar");
      const avatars = getAvatars();
      const selected = avatars.find(a => a.id === savedAvatarId && a.unlocked);
      return selected || avatars.find(a => a.unlocked) || avatars[0];
    }

    function renderAvatarGrid() {
      const selectedAvatar = getSelectedAvatar();
      const avatars = getAvatars();
      elements.avatarGrid.innerHTML = "";

      for (const avatar of avatars) {
        const div = document.createElement("div");
        const isSelected = avatar.id === selectedAvatar.id;
        const isLocked = !avatar.unlocked;

        div.className = "avatar-option" + (isSelected ? " selected" : "") + (isLocked ? " locked" : "");
        div.style.position = "relative";

        let progressHtml = "";
        if (isLocked && avatar.progress) {
          progressHtml = `
            <div class="progress-bar"><div class="progress-fill" style="width:${avatar.progress.percent}%"></div></div>
            <span class="progress-text">${avatar.progress.current}/${avatar.progress.required}</span>
          `;
        }

        div.innerHTML = `
          <img src="${avatar.src}" alt="${avatar.name}" />
          ${isLocked ? '<span class="lock-icon">üîí</span>' : ''}
          <span>${avatar.name}</span>
          ${progressHtml}
        `;

        if (isLocked) {
          div.title = avatar.progress?.description || "Locked";
        } else {
          div.addEventListener("click", () => selectAvatar(avatar.id));
        }

        elements.avatarGrid.appendChild(div);
      }
    }

    function selectAvatar(avatarId) {
      if (!TofAchievements.isAvatarUnlocked(avatarId)) return;
      localStorage.setItem("tof_avatar", avatarId);
      renderAvatarGrid();
      elements.raceAvatar.src = getSelectedAvatar().src;
    }

    // ========================================
    // Race Track Functions
    // ========================================
    function updateRaceTrack() {
      const verseNormalized = normalizeQuotes(state.verseText);
      const typedNormalized = normalizeQuotes(elements.input.value || "");

      if (!verseNormalized.length) return;

      let correctCharCount = 0;
      for (let i = 0; i < typedNormalized.length; i++) {
        if (typedNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        } else {
          break;
        }
      }

      const progress = correctCharCount / verseNormalized.length;
      const percentComplete = Math.round(progress * 100);

      const trackLane = document.querySelector(".track-lane");
      const maxLeftPosition = trackLane.offsetWidth - elements.raceAvatar.offsetWidth;

      elements.raceAvatar.style.left = Math.round(progress * maxLeftPosition) + "px";
      elements.racePct.textContent = percentComplete + "%";
    }

    function resetRaceTrack() {
      elements.raceAvatar.style.transition = "none";
      elements.raceAvatar.style.left = "0";
      elements.racePct.textContent = "0%";
      requestAnimationFrame(() => {
        elements.raceAvatar.style.transition = "left 0.3s ease-out";
      });
    }

    // ========================================
    // Utility Functions
    // ========================================
    function normalizeQuotes(text) {
      return (text || "")
        .replace(/['\u2018\u2019\u201A\u201B]/g, "'")
        .replace(/["\u201C\u201D\u201E\u201F]/g, '"');
    }

    function normalizeForComparison(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function clampInteger(value, min, max) {
      const parsed = Math.floor(isFinite(value) ? value : min);
      return Math.min(max, Math.max(min, parsed));
    }

    function classifyVerseLength(text) {
      const length = text.trim().length;
      if (length <= LENGTH_THRESHOLDS.shortMax) return "short";
      if (length <= LENGTH_THRESHOLDS.mediumMax) return "medium";
      return "long";
    }

    function getCurrentCategoryLabel() {
      return elements.category.value === "all" ? "All" : titleCase(elements.category.value);
    }

    function getRandomVerseReference(category) {
      if (category && category !== "all") {
        const verseList = VERSE_CATEGORIES[category] || [];
        const reference = verseList[Math.floor(Math.random() * verseList.length)];
        return { reference, category };
      }

      const reference = ALL_REFERENCES[Math.floor(Math.random() * ALL_REFERENCES.length)];
      const foundCategory = REF_TO_CATEGORY[reference] || "all";
      return { reference, category: foundCategory };
    }

    // ========================================
    // Levenshtein Distance (for Blind Faith scoring)
    // ========================================
    function levenshteinDistance(stringA, stringB) {
      const lengthA = stringA.length;
      const lengthB = stringB.length;

      const matrix = Array.from({ length: lengthA + 1 }, () => new Array(lengthB + 1));

      for (let i = 0; i <= lengthA; i++) matrix[i][0] = i;
      for (let j = 0; j <= lengthB; j++) matrix[0][j] = j;

      for (let i = 1; i <= lengthA; i++) {
        for (let j = 1; j <= lengthB; j++) {
          const cost = stringA[i - 1] === stringB[j - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }

      return matrix[lengthA][lengthB];
    }

    function computeFairnessScore(groundTruth, attempt) {
      const normalizedTruth = normalizeForComparison(groundTruth);
      const normalizedAttempt = normalizeForComparison(attempt);

      if (!normalizedTruth.length) {
        return { scorePercent: 0, distance: 0, baseLength: 0 };
      }

      const distance = levenshteinDistance(normalizedTruth, normalizedAttempt);
      const score = Math.max(0, 1 - distance / normalizedTruth.length);

      return {
        scorePercent: Math.round(score * 100),
        distance,
        baseLength: normalizedTruth.length
      };
    }

    // ========================================
    // HTTP Request Utilities
    // ========================================
    function createTimeoutController(timeoutMs) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      return {
        signal: controller.signal,
        cancel: () => clearTimeout(timeoutId)
      };
    }

    function classifyHttpError(error, response = null, bodyText = "") {
      const detail = (error && error.message) ? error.message : "";

      if (!response) {
        return {
          code: "NETWORK",
          userMessage: "Cannot reach the verse server.",
          hint: "If using FBV/ESV, start FastAPI (uvicorn server:app --reload --port 8000).",
          detail
        };
      }

      const status = response.status;

      if (status === 401) {
        return {
          code: "UNAUTHORIZED",
          userMessage: "The verse service rejected credentials.",
          hint: "Check API keys in .env / environment.",
          detail: bodyText
        };
      }

      if (status === 403) {
        return {
          code: "FORBIDDEN",
          userMessage: "This translation requires publisher permission.",
          hint: "Try KJV/WEB or an allowed version like FBV.",
          detail: bodyText
        };
      }

      if (status === 404) {
        return {
          code: "NOT_FOUND",
          userMessage: "No verse found for that reference.",
          hint: "Try a different verse or category.",
          detail: bodyText
        };
      }

      if (status === 502 || status === 503 || status === 504) {
        return {
          code: "UPSTREAM",
          userMessage: "Upstream provider unavailable.",
          hint: "Wait a moment and try again.",
          detail: bodyText
        };
      }

      return {
        code: "SERVER",
        userMessage: "The verse server hit an error.",
        hint: "Try again or switch to KJV/WEB.",
        detail: bodyText
      };
    }

    // ========================================
    // Verse Fetching
    // ========================================
    async function fetchViaProxy(reference, versionCode) {
      const baseUrl = "http://127.0.0.1:8000";
      const url = `${baseUrl}/verse?ref=${encodeURIComponent(reference)}&version=${encodeURIComponent(versionCode)}`;
      const { signal, cancel } = createTimeoutController(9000);

      try {
        const response = await fetch(url, { signal });
        const text = await response.text();

        if (!response.ok) {
          throw { isHttpError: true, response, text };
        }

        return JSON.parse(text);
      } catch (error) {
        const classified = error.isHttpError
          ? classifyHttpError(null, error.response, error.text)
          : classifyHttpError(error);
        const wrappedError = new Error(classified.userMessage);
        wrappedError.uiInfo = classified;
        throw wrappedError;
      } finally {
        cancel();
      }
    }

    async function fetchViaBibleApi(reference, versionCode) {
      const translation = (versionCode || "WEB").toLowerCase();
      const url = `https://bible-api.com/${encodeURIComponent(reference)}?translation=${encodeURIComponent(translation)}`;
      const { signal, cancel } = createTimeoutController(9000);

      try {
        const response = await fetch(url, { signal });
        const text = await response.text();

        if (!response.ok) {
          throw { isHttpError: true, response, text };
        }

        const data = JSON.parse(text);
        const verseText = Array.isArray(data.verses) && data.verses.length
          ? data.verses.map(verse => verse.text.trim()).join(" ")
          : (data.text || "");

        return {
          reference: data.reference || reference,
          text: verseText.replace(/\s+/g, " ").trim(),
          version: (versionCode || "WEB").toUpperCase(),
          fallback: true
        };
      } catch (error) {
        const classified = error.isHttpError
          ? classifyHttpError(null, error.response, error.text)
          : classifyHttpError(error);
        const wrappedError = new Error(classified.userMessage);
        wrappedError.uiInfo = classified;
        throw wrappedError;
      } finally {
        cancel();
      }
    }

    async function fetchVerseUnified(reference, versionCode) {
      try {
        return await fetchViaProxy(reference, versionCode);
      } catch (error) {
        const errorInfo = error.uiInfo || {};
        const publicVersions = ["KJV", "WEB"];

        if (publicVersions.includes(versionCode)) {
          showBanner("warn", `${errorInfo.userMessage || "Proxy unavailable."} Falling back to public provider for ${versionCode}...`);

          try {
            return await fetchViaBibleApi(reference, versionCode);
          } catch (fallbackError) {
            const fallbackInfo = fallbackError.uiInfo || {};
            showBanner("error", `${fallbackInfo.userMessage || "Failed to fetch verse."} ${fallbackInfo.hint ? "Hint: " + fallbackInfo.hint : ""}`);
            throw fallbackError;
          }
        }

        showBanner("error", `${errorInfo.userMessage || "Verse proxy error."} ${errorInfo.hint ? "Hint: " + errorInfo.hint : ""}`);
        throw error;
      }
    }

    async function fetchVerseMatchingLength(category, lengthPreference, versionCode) {
      if (lengthPreference === "any") {
        const pick = getRandomVerseReference(category);
        const result = await fetchVerseUnified(pick.reference, versionCode);
        return {
          reference: result.reference,
          text: result.text,
          category: REF_TO_CATEGORY[pick.reference] || category,
          copyright: result.copyright,
          version: result.version
        };
      }

      const MAX_ATTEMPTS = 8;
      let lastResult = null;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const pick = getRandomVerseReference(category);
        const result = await fetchVerseUnified(pick.reference, versionCode);
        const actualLength = classifyVerseLength(result.text);

        lastResult = {
          reference: result.reference,
          text: result.text,
          category: REF_TO_CATEGORY[pick.reference] || category,
          copyright: result.copyright,
          version: result.version
        };

        if (actualLength === lengthPreference) {
          return lastResult;
        }
      }

      return lastResult;
    }

    // ========================================
    // UI State Management
    // ========================================
    function setLoadingState(isLoading) {
      const buttons = [elements.newVerseButton, elements.restartButton, elements.peekButton, elements.submitButton].filter(Boolean);
      buttons.forEach(button => button.disabled = isLoading);
      elements.input.disabled = isLoading;

      if (isLoading) {
        elements.meta.textContent = "Loading verse...";
        showBanner("info", "Contacting verse providers...");
      } else if (/Contacting verse providers/.test(elements.banner.textContent)) {
        showBanner("info", "");
      }
    }

    function setTypingEnabled(enabled) {
      elements.input.readOnly = !enabled;
      elements.input.placeholder = enabled
        ? "Start typing the verse here..."
        : "Typing disabled while verse is visible (Blind Faith)";
    }

    function setBlindFaithUIVisible(visible) {
      elements.blindFaithControls.style.display = visible ? "flex" : "none";
      elements.submitButton.style.display = visible ? "block" : "none";
      syncPeekButtonLabel();
    }

    function syncPeekButtonLabel() {
      const seconds = clampInteger(Number(elements.peekSeconds.value || DEFAULT_PEEK_SECONDS), 1, 10);
      if (elements.peekButton) {
        elements.peekButton.textContent = `Peek Verse (${seconds}s)`;
      }
    }

    // ========================================
    // Timer Utilities
    // ========================================
    function getPreviewMilliseconds() {
      const seconds = clampInteger(
        Number(elements.previewSeconds.value || localStorage.getItem("tof_preview_sec") || DEFAULT_PREVIEW_SECONDS),
        1,
        30
      );
      elements.previewSeconds.value = seconds;
      localStorage.setItem("tof_preview_sec", String(seconds));
      return seconds * 1000;
    }

    function getPeekMilliseconds() {
      const seconds = clampInteger(
        Number(elements.peekSeconds.value || localStorage.getItem("tof_peek_sec") || DEFAULT_PEEK_SECONDS),
        1,
        10
      );
      elements.peekSeconds.value = seconds;
      localStorage.setItem("tof_peek_sec", String(seconds));
      return seconds * 1000;
    }

    function clearAllTimers() {
      if (state.hideTimer) {
        clearTimeout(state.hideTimer);
        state.hideTimer = null;
      }
      if (state.peekTimer) {
        clearTimeout(state.peekTimer);
        state.peekTimer = null;
      }
      if (state.countdownTimer) {
        clearInterval(state.countdownTimer);
        state.countdownTimer = null;
      }
    }

    // ========================================
    // Verse Display Functions
    // ========================================
    function showVerse() {
      elements.hiddenMask.textContent = "";
      elements.typed.textContent = "";
      elements.incorrect.textContent = "";
      elements.remaining.textContent = state.verseText;

      if (elements.blindToggle.checked) {
        setTypingEnabled(false);
      }
    }

    function hideVerse() {
      elements.typed.textContent = "";
      elements.incorrect.textContent = "";
      elements.remaining.textContent = "";
      elements.hiddenMask.textContent = "‚Äî Verse hidden ‚Äî type from memory ‚Äî";

      if (elements.blindToggle.checked) {
        setTypingEnabled(true);
        elements.input.focus();
      }
    }

    function resetTypingArea(verseText, reference) {
      state.verseText = verseText;
      state.reference = reference;

      elements.typed.textContent = "";
      elements.incorrect.textContent = "";
      elements.remaining.textContent = state.verseText;
      elements.hiddenMask.textContent = "";

      elements.input.value = "";
      elements.input.classList.remove("error-state");
      elements.banner.textContent = "";
      elements.result.textContent = "‚Äî";
      elements.copyline.textContent = "";

      state.peekCount = 0;
      elements.peekCount.textContent = "0";

      state.started = false;
      state.startTime = 0;
      state.finished = false;
      state.totalKeystrokes = 0;
      state.errorKeystrokes = 0;
      state.errorPositions.clear();
      state.previousInputValue = "";

      updateLiveMetrics();
      resetRaceTrack();
      setTypingEnabled(true);
    }

    // ========================================
    // Blind Faith Mode
    // ========================================
    function startBlindPreviewCountdown() {
      const totalMs = getPreviewMilliseconds();
      let remainingMs = totalMs;

      showBanner("info", `Blind Faith: Memorise the verse... Hiding in ${Math.round(remainingMs / 1000)}s`);

      state.countdownTimer = setInterval(() => {
        remainingMs -= 1000;

        if (remainingMs <= 0) {
          clearInterval(state.countdownTimer);
          state.countdownTimer = null;
        } else {
          showBanner("info", `Blind Faith: Memorise the verse... Hiding in ${Math.round(remainingMs / 1000)}s`);
        }
      }, 1000);

      state.hideTimer = setTimeout(() => {
        hideVerse();
        showBanner("info", "Blind Faith: Type from memory. Use Peek if needed.");
        state.hideTimer = null;
      }, totalMs);
    }

    function handlePeek() {
      if (state.peekTimer) return;

      state.peekCount += 1;
      elements.peekCount.textContent = String(state.peekCount);

      showVerse();

      const peekDuration = getPeekMilliseconds();
      state.peekTimer = setTimeout(() => {
        hideVerse();
        state.peekTimer = null;
      }, peekDuration);
    }

    // ========================================
    // Metrics Calculation
    // ========================================
    function getElapsedSeconds() {
      if (!state.started) return 0;
      return (performance.now() - state.startTime) / 1000;
    }

    function computeLiveMetrics(currentTypedText) {
      const elapsedSeconds = getElapsedSeconds();
      const elapsedMinutes = elapsedSeconds / 60;

      const verseNormalized = normalizeQuotes(state.verseText);
      const typedNormalized = normalizeQuotes(currentTypedText || "");

      let correctCharCount = 0;
      for (let i = 0; i < typedNormalized.length; i++) {
        if (typedNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        }
      }

      const wordsPerMinute = elapsedMinutes > 0 ? (correctCharCount / 5) / elapsedMinutes : 0;
      const accuracy = state.totalKeystrokes > 0
        ? Math.max(0, 1 - (state.errorKeystrokes / state.totalKeystrokes))
        : 1;

      return {
        wpm: Math.round(wordsPerMinute),
        accuracyPercent: Math.round(accuracy * 100),
        timeSeconds: elapsedSeconds
      };
    }

    function updateLiveMetrics() {
      const metrics = computeLiveMetrics(elements.input.value || "");
      elements.status.textContent = `WPM: ${metrics.wpm} ¬∑ Accuracy: ${metrics.accuracyPercent}% ¬∑ Time: ${metrics.timeSeconds.toFixed(1)}s`;
    }

    // ========================================
    // History & Results
    // ========================================
    function addHistoryRow(entry) {
      const row = document.createElement("tr");
      const cells = [
        entry.timeLocal,
        entry.category,
        entry.reference,
        entry.mode,
        String(entry.peekCount),
        entry.seconds.toFixed(2),
        String(entry.wpm),
        String(entry.accuracyPercent),
        entry.fairnessPercent != null ? String(entry.fairnessPercent) : "‚Äî"
      ];

      for (const cellText of cells) {
        const cell = document.createElement("td");
        cell.textContent = cellText;
        row.appendChild(cell);
      }

      elements.historyBody.prepend(row);
    }

    function exportHistoryToCSV() {
      const headers = ["Time", "Category", "Reference", "Mode", "Peeks", "Seconds", "WPM", "AccuracyPct", "FairnessPct"];
      const rows = [headers.join(",")];

      for (const entry of state.history) {
        const row = [
          `"${entry.timeLocal.replace(/"/g, '""')}"`,
          `"${entry.category}"`,
          `"${entry.reference.replace(/"/g, '""')}"`,
          `"${entry.mode}"`,
          entry.peekCount,
          entry.seconds.toFixed(2),
          entry.wpm,
          entry.accuracyPercent,
          entry.fairnessPercent != null ? entry.fairnessPercent : ""
        ];
        rows.push(row.join(","));
      }

      const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = "type-of-faith-session.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      URL.revokeObjectURL(url);
    }

    // ========================================
    // Celebration Animations
    // ========================================
    function showConfetti() {
      const overlay = document.getElementById("celebrationOverlay");
      overlay.innerHTML = "";
      const colors = ["#ffd700", "#ff6b6b", "#6ee7a0", "#87b3ff", "#ff9ff3", "#feca57"];

      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement("div");
        confetti.className = "confetti";
        confetti.style.left = Math.random() * 100 + "%";
        confetti.style.top = "-20px";
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.borderRadius = Math.random() > 0.5 ? "50%" : "2px";
        confetti.style.width = (Math.random() * 8 + 6) + "px";
        confetti.style.height = (Math.random() * 8 + 6) + "px";
        confetti.style.animationDelay = (Math.random() * 0.5) + "s";
        confetti.style.animationDuration = (Math.random() * 1 + 2.5) + "s";
        overlay.appendChild(confetti);
        requestAnimationFrame(() => confetti.classList.add("animate"));
      }
      setTimeout(() => { overlay.innerHTML = ""; }, 4000);
    }

    function showCompletionBadge(emoji = "‚úÖ") {
      const badge = document.getElementById("completionBadge");
      badge.textContent = emoji;
      badge.classList.add("show");
      setTimeout(() => badge.classList.remove("show"), 1200);
    }

    function showWpmMilestone(wpm, milestone) {
      const el = document.getElementById("wpmMilestone");
      el.innerHTML = `üî• ${wpm} WPM!<br><span style="font-size:16px">New personal best!</span>`;
      el.classList.add("show");
      setTimeout(() => el.classList.remove("show"), 2000);
    }

    function showAchievementToast(avatarId, avatarName) {
      const toast = document.getElementById("achievementToast");
      const avatar = document.getElementById("toastAvatar");
      const name = document.getElementById("toastName");

      avatar.src = `assets/avatars/${avatarId}-2d.png`;
      avatar.alt = avatarName;
      name.textContent = `${avatarName} Unlocked!`;

      toast.classList.add("show");
      setTimeout(() => toast.classList.remove("show"), 4000);
    }

    function finishAttempt(isBlindFinish = false) {
      if (state.finished) return;
      state.finished = true;
      TofAudio.playComplete();

      // Track if this is a new personal best for celebration purposes
      let isNewBestWPM = false;

      const attempt = elements.input.value || "";
      const elapsedSeconds = getElapsedSeconds();
      const elapsedMinutes = elapsedSeconds / 60;

      const verseNormalized = normalizeQuotes(state.verseText);
      const attemptNormalized = normalizeQuotes(attempt);

      let correctCharCount = 0;
      for (let i = 0; i < attemptNormalized.length; i++) {
        if (attemptNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        }
      }

      const wordsPerMinute = elapsedMinutes > 0 ? Math.round((correctCharCount / 5) / elapsedMinutes) : 0;
      const accuracy = state.totalKeystrokes > 0
        ? Math.max(0, 1 - (state.errorKeystrokes / state.totalKeystrokes))
        : 1;
      const accuracyPercent = Math.round(accuracy * 100);

      let resultText = `Ref: ${state.reference} ¬∑ Time: ${elapsedSeconds.toFixed(2)}s ¬∑ WPM: ${wordsPerMinute} ¬∑ Accuracy: ${accuracyPercent}%`;
      let fairnessPercent = null;

      if (elements.blindToggle.checked || isBlindFinish) {
        const fairnessResult = computeFairnessScore(state.verseText, attempt);
        fairnessPercent = fairnessResult.scorePercent;
        resultText += ` ¬∑ Fairness: ${fairnessPercent}% ¬∑ Peeks: ${state.peekCount}`;

        if (state.bestFairness === null || fairnessPercent > state.bestFairness) {
          state.bestFairness = fairnessPercent;
        }
      }

      elements.result.textContent = resultText;

      if (elements.blindToggle.checked) {
        showVerse();
        setTypingEnabled(false);
        showBanner("info", "Blind Faith: Verse revealed for review. Use Restart or New Verse when ready.");
      }

      // Update best stats
      if (state.bestWPM === null || wordsPerMinute > state.bestWPM) {
        isNewBestWPM = state.bestWPM !== null; // Only celebrate if it's beating a previous record
        state.bestWPM = wordsPerMinute;
      }
      if (state.bestAccuracy === null || accuracyPercent > state.bestAccuracy) {
        state.bestAccuracy = accuracyPercent;
      }
      if (state.fastestTime === null || elapsedSeconds < state.fastestTime) {
        state.fastestTime = elapsedSeconds;
      }

      elements.bestStats.textContent = `Best WPM: ${state.bestWPM ?? "‚Äî"} ¬∑ Best Accuracy: ${state.bestAccuracy ?? "‚Äî"}% ¬∑ Fastest Time: ${state.fastestTime ? state.fastestTime.toFixed(2) + "s" : "‚Äî"} ¬∑ Best Fairness (Blind): ${state.bestFairness ?? "‚Äî"}%`;

      // Celebration animations
      if (accuracyPercent >= 95) {
        showCompletionBadge(accuracyPercent === 100 ? "üåü" : "‚úÖ");
        if (accuracyPercent === 100 && wordsPerMinute >= 40) {
          showConfetti();
        }
      }
      if (isNewBestWPM && wordsPerMinute >= 30) {
        setTimeout(() => showWpmMilestone(wordsPerMinute), 1500);
      }

      // Add to history
      const historyEntry = {
        timeLocal: new Date().toLocaleString(),
        category: titleCase(state.actualCategory),
        reference: state.reference,
        mode: elements.blindToggle.checked ? "Blind" : "Normal",
        peekCount: state.peekCount,
        seconds: elapsedSeconds,
        wpm: wordsPerMinute,
        accuracyPercent,
        fairnessPercent
      };

      state.history.push(historyEntry);
      addHistoryRow(historyEntry);

      // Save daily challenge best
      if (state.isDailyChallenge) {
        const isNewBest = saveDailyBest(wordsPerMinute, accuracyPercent, elapsedSeconds.toFixed(2));
        if (isNewBest) {
          showBanner("success", `New daily best! ${wordsPerMinute} WPM`);
        }
        // Update the daily challenge display with actual best (not current attempt)
        const best = getDailyBest();
        const dailyBestEl = document.getElementById('dailyBest');
        if (dailyBestEl && best) {
          dailyBestEl.innerHTML = `Your best today: <strong>${best.wpm} WPM</strong> ¬∑ ${best.accuracy}% accuracy ¬∑ ${best.time}s`;
        }
        // Record daily challenge completion
        TofAchievements.recordDailyChallenge();

        // Submit to global leaderboard (if logged in)
        submitToLeaderboard(wordsPerMinute, accuracyPercent, elapsedSeconds, state.reference).then(result => {
          if (result && result.rank) {
            showBanner("success", result.message);
          }
        });
      }

      // Record practice session and check for new avatar unlocks
      const newUnlocks = TofAchievements.recordPracticeSession(wordsPerMinute, accuracyPercent);
      if (newUnlocks && newUnlocks.length > 0) {
        // Use the new toast animation for unlocks (delay to avoid overlap)
        newUnlocks.forEach((avatar, i) => {
          setTimeout(() => showAchievementToast(avatar.id, avatar.name), 3000 + (i * 4500));
        });
        renderAvatarGrid(); // Refresh to show newly unlocked avatar
      }
    }

    // ========================================
    // Main Verse Loading
    // ========================================
    async function loadRandomVerse() {
      clearAllTimers();
      setLoadingState(true);
      state.isDailyChallenge = false;

      const category = elements.category.value;
      const lengthPreference = elements.length.value;
      const versionCode = (elements.version.value || "WEB").toUpperCase();

      elements.meta.textContent = "Loading verse...";
      elements.copyline.textContent = "";
      elements.categoryTitle.textContent = getCurrentCategoryLabel();

      try {
        const result = await fetchVerseMatchingLength(category, lengthPreference, versionCode);

        if (!result || !result.text) {
          throw new Error("Empty verse text");
        }

        showBanner("success", "Verse loaded. Happy typing!");
        resetTypingArea(result.text, result.reference);

        state.actualCategory = result.category || category;
        elements.categoryTitle.textContent = titleCase(state.actualCategory);

        const isBlindMode = elements.blindToggle.checked;
        setBlindFaithUIVisible(isBlindMode);

        if (isBlindMode) {
          showVerse();
          startBlindPreviewCountdown();
        } else {
          setTypingEnabled(true);
          showVerse();
          elements.banner.style.display = "none";
        }

        const lengthClass = classifyVerseLength(result.text);
        const fallbackNote = result.fallback ? " ¬∑ (fallback source)" : "";
        elements.meta.textContent = `${state.reference} (${(result.version || versionCode).toUpperCase()}) ¬∑ ${titleCase(lengthClass)}${fallbackNote}`;

        if (result.copyright) {
          elements.copyline.textContent = result.copyright;
        }
      } catch (error) {
        const errorInfo = error.uiInfo || {};
        showBanner("error", `${errorInfo.userMessage || "Could not load verse."} ${errorInfo.hint ? "Hint: " + errorInfo.hint : ""}`);
        console.error("Verse load failed:", errorInfo.detail || error);
      } finally {
        setLoadingState(false);

        // Focus input after loading completes (when not in blind mode)
        if (!elements.blindToggle.checked) {
          elements.input.focus();
        }
      }
    }

    async function loadSpecificVerse(reference, versionCode = "WEB") {
      clearAllTimers();
      setLoadingState(true);
      state.isDailyChallenge = true;

      elements.meta.textContent = "Loading daily challenge...";
      elements.copyline.textContent = "";
      elements.categoryTitle.textContent = "Daily Challenge";

      try {
        const result = await fetchViaProxy(reference, versionCode);

        if (!result || !result.text) {
          throw new Error("Empty verse text");
        }

        showBanner("success", "Daily Challenge loaded. Good luck!");
        resetTypingArea(result.text, result.reference || reference);

        state.actualCategory = "Daily Challenge";

        // Disable blind mode for daily challenge
        elements.blindToggle.checked = false;
        elements.blindFaithCard.classList.remove("active");
        elements.blindFaithToggleBtn.textContent = "Activate";
        elements.bfSettings.style.display = "none";
        setBlindFaithUIVisible(false);
        setTypingEnabled(true);
        showVerse();
        elements.banner.style.display = "none";

        const lengthClass = classifyVerseLength(result.text);
        elements.meta.textContent = `${state.reference} (${versionCode}) ¬∑ ${titleCase(lengthClass)} ¬∑ Daily Challenge`;

        if (result.copyright) {
          elements.copyline.textContent = result.copyright;
        }
      } catch (error) {
        showBanner("error", "Could not load daily verse. Please try again.");
        console.error("Daily verse load failed:", error);
        state.isDailyChallenge = false;
      } finally {
        setLoadingState(false);
        elements.input.focus();
      }
    }

    function restartCurrentVerse() {
      clearAllTimers();
      resetTypingArea(state.verseText, state.reference);
      elements.categoryTitle.textContent = titleCase(state.actualCategory);

      const isBlindMode = elements.blindToggle.checked;
      setBlindFaithUIVisible(isBlindMode);

      if (isBlindMode) {
        showVerse();
        startBlindPreviewCountdown();
      } else {
        setTypingEnabled(true);
        showVerse();
        elements.input.focus();
      }
    }

    // ========================================
    // Input Handling
    // ========================================
    elements.input.addEventListener("input", () => {
      const currentValue = elements.input.value;
      const verseNormalized = normalizeQuotes(state.verseText);
      const currentNormalized = normalizeQuotes(currentValue);
      const previousNormalized = normalizeQuotes(state.previousInputValue);

      // Block typing if blind mode and verse is still visible
      if (elements.blindToggle.checked && elements.remaining.textContent.length > 0) {
        setTypingEnabled(false);
        elements.input.value = state.previousInputValue;
        return;
      }

      // Track keystrokes for accuracy calculation
      if (currentValue.length > state.previousInputValue.length) {
        const addedChars = currentNormalized.slice(previousNormalized.length);
        let hasErrorThisInput = false;

        for (let i = 0; i < addedChars.length; i++) {
          const charIndex = previousNormalized.length + i;
          const typedChar = addedChars[i];

          state.totalKeystrokes++;
          if (typedChar !== verseNormalized[charIndex]) {
            state.errorKeystrokes++;
            state.errorPositions.add(charIndex); // Track position where error occurred
            hasErrorThisInput = true;
          }
        }

        // Play audio feedback
        if (hasErrorThisInput) {
          TofAudio.playError();
        } else {
          TofAudio.playCorrect();
        }
      }

      state.previousInputValue = currentValue;

      // Start timer on first keystroke
      if (!state.started && currentValue.length > 0) {
        state.started = true;
        state.startTime = performance.now();
      }

      updateLiveMetrics();
      updateRaceTrack();

      // Find the first error position
      let correctCharCount = 0;
      for (let i = 0; i < currentNormalized.length; i++) {
        if (currentNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        } else {
          break;
        }
      }

      const hasError = correctCharCount < currentValue.length;
      const errorCharCount = currentValue.length - correctCharCount;

      const isBlindMode = elements.blindToggle.checked;
      const isVerseVisible = elements.remaining.textContent.length > 0 || elements.hiddenMask.textContent.length === 0;

      if (!isBlindMode || isVerseVisible) {
        // Update verse display: correct (green), corrected (yellow), incorrect (red), remaining (muted)
        let typedHtml = '';
        for (let k = 0; k < correctCharCount; k++) {
          if (state.errorPositions.has(k)) {
            typedHtml += `<span class="corrected">${state.verseText[k]}</span>`;
          } else {
            typedHtml += state.verseText[k];
          }
        }
        elements.typed.innerHTML = typedHtml;
        elements.incorrect.textContent = state.verseText.substring(correctCharCount, correctCharCount + errorCharCount);
        elements.remaining.textContent = state.verseText.substring(correctCharCount + errorCharCount);

        // Update input error state
        if (hasError) {
          elements.input.classList.add("error-state");
        } else {
          elements.input.classList.remove("error-state");
        }

        // Check for completion
        if (currentValue.length === state.verseText.length && !hasError) {
          finishAttempt(false);
        }
      } else {
        // Blind mode with verse hidden - just update input state
        if (hasError) {
          elements.input.classList.add("error-state");
        } else {
          elements.input.classList.remove("error-state");
        }
      }
    });

    // ========================================
    // Event Listeners
    // ========================================
    elements.newVerseButton.addEventListener("click", loadRandomVerse);
    elements.restartButton.addEventListener("click", restartCurrentVerse);
    elements.category.addEventListener("change", loadRandomVerse);
    elements.length.addEventListener("change", loadRandomVerse);
    elements.version.addEventListener("change", loadRandomVerse);

    elements.blindFaithToggleBtn.addEventListener("click", () => {
      elements.blindToggle.checked = !elements.blindToggle.checked;
      elements.blindToggle.dispatchEvent(new Event("change"));
    });

    elements.blindToggle.addEventListener("change", () => {
      const active = elements.blindToggle.checked;
      elements.blindFaithCard.classList.toggle("active", active);
      elements.blindFaithToggleBtn.textContent = active ? "Deactivate" : "Activate";
      elements.bfSettings.style.display = active ? "flex" : "none";
      setBlindFaithUIVisible(active);
      loadRandomVerse();
    });

    elements.previewSeconds.addEventListener("change", () => getPreviewMilliseconds());
    elements.peekSeconds.addEventListener("change", () => {
      getPeekMilliseconds();
      syncPeekButtonLabel();
    });

    if (elements.peekButton) {
      elements.peekButton.addEventListener("click", handlePeek);
    }

    elements.submitButton.addEventListener("click", () => finishAttempt(true));

    elements.exportButton.addEventListener("click", exportHistoryToCSV);

    // Keyboard shortcuts
    document.addEventListener("keydown", (event) => {
      if (event.ctrlKey && event.key === "Enter") {
        event.preventDefault();
        finishAttempt(true);
      } else if (event.ctrlKey && event.key.toLowerCase() === "p") {
        event.preventDefault();
        handlePeek();
      } else if (event.ctrlKey && event.key.toLowerCase() === "r") {
        event.preventDefault();
        restartCurrentVerse();
      } else if (event.ctrlKey && event.key.toLowerCase() === "m") {
        event.preventDefault();
        loadRandomVerse();
      } else if (event.ctrlKey && event.key.toLowerCase() === "j") {
        event.preventDefault();
        const themeModes = ["auto", "light", "dark"];
        const currentTheme = localStorage.getItem(THEME_KEY) || "auto";
        const nextIndex = (themeModes.indexOf(currentTheme) + 1) % themeModes.length;
        applyTheme(themeModes[nextIndex]);
      }
    });

    // ========================================
    // User Bar & Leaderboard
    // ========================================
    function renderUserBar() {
      const userInfo = document.getElementById('userInfo');
      const user = TofLeaderboard.getCurrentUser();

      if (user) {
        userInfo.innerHTML = `
          <img class="user-avatar" src="assets/avatars/${getSelectedAvatar().id}-2d.png" alt="" />
          <span class="user-name">${user.username}</span>
          <span class="user-stats">Best: ${user.best_wpm || 0} WPM</span>
          <button id="logoutBtn">Log Out</button>
        `;
        document.getElementById('logoutBtn').addEventListener('click', async () => {
          await TofLeaderboard.logout();
          renderUserBar();
        });
      } else {
        userInfo.innerHTML = `
          <span class="login-prompt">Log in to save scores to the leaderboard</span>
          <button id="loginBtn">Join Leaderboard</button>
        `;
        document.getElementById('loginBtn').addEventListener('click', async () => {
          try {
            await TofLeaderboard.showAuthModal();
            renderUserBar();
            loadLeaderboard();
          } catch (e) {
            // User cancelled
          }
        });
      }
    }

    async function loadLeaderboard() {
      const container = document.getElementById('leaderboardContainer');
      try {
        const data = await TofLeaderboard.getDailyLeaderboard();
        TofLeaderboard.renderLeaderboard(data, 'leaderboardContainer');
      } catch (e) {
        container.innerHTML = '<p style="color:var(--muted)">Could not load leaderboard. Server may be offline.</p>';
      }
    }

    // Submit score to leaderboard when daily challenge is completed
    async function submitToLeaderboard(wpm, accuracy, timeSeconds, verseRef) {
      if (!TofLeaderboard.isAuthenticated()) return null;

      try {
        const result = await TofLeaderboard.submitDailyScore(wpm, accuracy, timeSeconds, verseRef);
        loadLeaderboard(); // Refresh leaderboard
        return result;
      } catch (e) {
        console.warn('Failed to submit score:', e);
        return null;
      }
    }

    // ========================================
    // Seasonal Features
    // ========================================
    function initSeasonalFeatures() {
      const season = TofSeasons.getCurrentSeason();
      if (season) {
        // Apply theme colors
        TofSeasons.applySeasonalTheme(season);

        // Show seasonal banner
        const container = document.getElementById('seasonalBannerContainer');
        if (container) {
          container.innerHTML = TofSeasons.createSeasonalBanner(season);
        }

        console.log(`Seasonal event active: ${season.name}`);
      }
    }

    // ========================================
    // Initialization
    // ========================================
    (async () => {
      initTheme();
      initSeasonalFeatures();
      renderAvatarGrid();
      elements.raceAvatar.src = getSelectedAvatar().src;
      initDailyChallenge();

      elements.previewSeconds.value = localStorage.getItem("tof_preview_sec") ?? DEFAULT_PREVIEW_SECONDS;
      elements.peekSeconds.value = localStorage.getItem("tof_peek_sec") ?? DEFAULT_PEEK_SECONDS;
      syncPeekButtonLabel();
      const blindActive = elements.blindToggle.checked;
      elements.blindFaithCard.classList.toggle("active", blindActive);
      elements.blindFaithToggleBtn.textContent = blindActive ? "Deactivate" : "Activate";
      elements.bfSettings.style.display = blindActive ? "flex" : "none";
      setBlindFaithUIVisible(blindActive);

      elements.categoryTitle.textContent = getCurrentCategoryLabel();

      // Check if proxy is available
      try {
        const response = await fetch("http://127.0.0.1:8000/health", { cache: "no-store" });
        if (!response.ok) throw new Error("Proxy offline");

        // Initialize user bar and leaderboard
        await TofLeaderboard.checkAuth();
        renderUserBar();
        loadLeaderboard();

        // Add refresh button handler
        document.getElementById('refreshLeaderboard').addEventListener('click', loadLeaderboard);
      } catch {
        showBanner("warn", "Proxy offline. KJV/WEB will fall back to public provider. Start FastAPI for FBV/ESV and leaderboard.");
        document.getElementById('userBar').style.display = 'none';
        document.getElementById('leaderboardPanel').style.display = 'none';
      }

      // Load initial verse
      await loadRandomVerse();
    })();
  </script>
</body>
</html>
