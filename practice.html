<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <title>Type of Faith MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%93%96%3C/text%3E%3C/svg%3E">
  <link rel="stylesheet" href="shared/nav.css" />
  <style>
    /* ========== Light theme (default) ========== */
    :root {
      --bg: #faf8f5;
      --ink: #111;
      --muted: #555;
      --ok: #0a7a0a;
      --err: #b00020;
      --accent: #8b6b3b;
      --panel: #fff;
      --border: #eee;
      --banner-bg: #fff7e6;
      --link: #1a56db;
      --input-border: #ddd;
      --btn-border: #ccc;
    }

    /* ========== Dark theme overrides ========== */
    :root[data-theme="dark"] {
      --bg: #0f1115;
      --ink: #e6e6e6;
      --muted: #a8a8a8;
      --ok: #6ee7a0;
      --err: #ff6b81;
      --accent: #d7c3a0;
      --panel: #151922;
      --border: #2a2f3a;
      --banner-bg: #1d2430;
      --link: #87b3ff;
      --input-border: #2b3240;
      --btn-border: #3a4252;
    }

    /* ========== Base styles ========== */
    * { box-sizing: border-box; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      margin: 24px;
    }

    a { color: var(--link); }

    h2 {
      margin: 8px 0 16px;
      font-weight: 600;
      color: var(--ink);
    }

    /* ========== Controls ========== */
    .controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px;
    }

    select, button, label, input[type="number"] { font-size: 16px; }
    select, button, input[type="number"] { padding: 8px 10px; }

    input[type="number"] {
      width: 80px;
      background: var(--panel);
      color: var(--ink);
      border: 1px solid var(--input-border);
      border-radius: 6px;
    }

    button {
      cursor: pointer;
      border: 1px solid var(--btn-border);
      background: var(--panel);
      color: var(--ink);
      border-radius: 6px;
    }

    button:active { transform: translateY(1px); }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    /* ========== Verse display ========== */
    #meta {
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    #banner {
      font-size: 14px;
      color: var(--accent);
      margin: 6px 0 10px;
      padding: 6px 8px;
      border-radius: 6px;
      background: var(--banner-bg);
      display: none;
    }

    #verse {
      font-size: 20px;
      line-height: 1.6;
      margin-bottom: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      min-height: 3.5em;
    }

    #typed { color: var(--ok); }

    #incorrect {
      color: #fff;
      background: var(--err);
      border-radius: 2px;
      padding: 0 1px;
    }

    .corrected { background: rgba(253, 224, 71, 0.35); border-radius: 2px; }

    #remaining { color: var(--muted); }

    #hiddenMask {
      color: var(--muted);
      font-style: italic;
    }

    .copyline {
      font-size: 12px;
      color: var(--muted);
      margin: 6px 0 8px;
    }

    /* ========== Input field ========== */
    #input {
      width: 100%;
      font-size: 20px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--input-border);
      background: var(--panel);
      color: var(--ink);
      margin: 12px 0;
    }

    #input.error-state {
      background: color-mix(in srgb, var(--err) 10%, var(--panel));
      border-color: var(--err);
      box-shadow: 0 2px 0 var(--err);
    }

    /* ========== Blind Faith controls ========== */
    .bf-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 8px 0;
    }

    .right { margin-left: auto; }
    .hint { font-size: 12px; color: var(--muted); }

    /* ========== Stats panels ========== */
    .panels {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }

    .stat { font-variant-numeric: tabular-nums; }

    #status { font-size: 14px; color: var(--muted); }
    #result { font-size: 16px; }
    #bestStats { font-size: 14px; }
    #peekCount { font-weight: 600; }

    /* ========== History table ========== */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--border);
    }

    th { background: color-mix(in srgb, var(--panel) 60%, var(--border)); }

    @media (min-width: 1000px) {
      .panels { grid-template-columns: 1fr 1fr; }
    }

    /* ========== Avatar panel ========== */
    .avatar-panel { margin-bottom: 12px; }

    .avatar-grid {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .avatar-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      padding: 6px;
      border-radius: 8px;
      border: 2px solid transparent;
      transition: border-color 0.2s;
    }

    .avatar-option:hover { border-color: var(--accent); }

    .avatar-option.selected {
      border-color: var(--ok);
      background: color-mix(in srgb, var(--ok) 10%, transparent);
    }

    .avatar-option img {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      object-fit: cover;
    }

    .avatar-option span {
      font-size: 11px;
      color: var(--muted);
    }

    /* ========== Race track ========== */
    .race-track {
      margin: 8px 0;
      padding: 6px 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .track-lane {
      position: relative;
      height: 40px;
      background: color-mix(in srgb, var(--border) 50%, transparent);
      border-radius: 20px;
      overflow: hidden;
    }

    .race-avatar {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      left: 0;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      object-fit: cover;
      z-index: 2;
      transition: left 0.3s ease-out;
    }

    .finish-line {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: repeating-linear-gradient(
        to bottom,
        var(--ink) 0px,
        var(--ink) 4px,
        var(--panel) 4px,
        var(--panel) 8px
      );
      border-right: 2px solid var(--ok);
      z-index: 1;
    }

    .race-pct {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      z-index: 3;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <script src="shared/data.js"></script>
  <script src="shared/nav.js"></script>
  <script src="shared/theme.js"></script>

  <div class="controls">
    <label>
      Category:
      <select id="category">
        <option value="all">All</option>
        <option value="anger">Anger</option>
        <option value="anxiety">Anxiety</option>
        <option value="courage">Courage</option>
        <option value="depression">Depression</option>
        <option value="doubt">Doubt</option>
        <option value="faith">Faith</option>
        <option value="fear">Fear</option>
        <option value="forgiveness">Forgiveness</option>
        <option value="healing">Healing</option>
        <option value="hope">Hope</option>
        <option value="jealousy">Jealousy</option>
        <option value="joy">Joy</option>
        <option value="loss">Loss</option>
        <option value="love">Love</option>
        <option value="patience">Patience</option>
        <option value="peace">Peace</option>
        <option value="pride">Pride</option>
        <option value="stress">Stress</option>
        <option value="temptation">Temptation</option>
        <option value="wisdom">Wisdom</option>
      </select>
    </label>

    <label>
      Verse length:
      <select id="length">
        <option value="any">Any</option>
        <option value="short">Short</option>
        <option value="medium">Medium</option>
        <option value="long">Long</option>
      </select>
    </label>

    <label>
      Version:
      <select id="version">
        <option value="KJV">KJV (bible-api.com)</option>
        <option value="WEB">WEB (World English Bible)</option>
        <option value="FBV">FBV (api.bible via proxy)</option>
        <option value="ESV">ESV (Crossway API via proxy)</option>
      </select>
    </label>

    <label class="toggle" title="Show verse briefly, then hide it so you type from memory">
      <input type="checkbox" id="blindToggle" />
      Blind Faith
    </label>

    <label id="previewLabel" class="toggle" title="Initial visible time before hiding (1-30s)" style="display:none">
      Preview (s):
      <input id="previewSec" type="number" min="1" max="30" step="1" />
    </label>

    <label id="peekLabel" class="toggle" title="Peek reveal time (1-10s)" style="display:none">
      Peek (s):
      <input id="peekSec" type="number" min="1" max="10" step="1" />
    </label>

    <button id="newVerseBtn" title="Ctrl+M">New Verse</button>
    <button id="restartBtn" title="Restart this verse (Ctrl+R)">Restart</button>
  </div>

  <div id="avatarPanel" class="card avatar-panel">
    <strong>Choose Your Character</strong>
    <div class="avatar-grid" id="avatarGrid"></div>
  </div>

  <h2 id="categoryTitle">All</h2>

  <div id="meta"></div>
  <div id="banner"></div>

  <div id="verse">
    <span id="typed"></span><span id="incorrect"></span><span id="remaining"></span><span id="hiddenMask"></span>
  </div>

  <div class="copyline" id="copyline"></div>

  <div class="bf-controls" id="bfControls" style="display:none;">
    <button id="peekBtn" title="Reveal the verse (Ctrl+P)">Peek Verse</button>
    <button id="finishBtn" title="Calculate your fairness score (Ctrl+Enter)">Finish Attempt</button>
    <span>Peeks used: <span id="peekCount">0</span></span>
    <span class="hint right">Shortcuts: Ctrl+P peek · Ctrl+Enter finish · Ctrl+R restart · Ctrl+M new</span>
  </div>

  <div id="raceTrack" class="race-track">
    <div class="track-lane">
      <img id="raceAvatar" class="race-avatar" src="" alt="avatar" />
      <span id="racePct" class="race-pct">0%</span>
      <div class="finish-line"></div>
    </div>
  </div>

  <input id="input" placeholder="Start typing the verse here..." autocomplete="off" spellcheck="false" />

  <div class="panels">
    <div class="card">
      <strong>Live Metrics</strong>
      <div id="status" class="stat">WPM: 0 · Accuracy: 100% · Time: 0.0s</div>
    </div>
    <div class="card">
      <strong>Result</strong>
      <div id="result" class="stat">—</div>
    </div>
    <div class="card" style="grid-column: 1 / -1;">
      <strong>Best of Session</strong>
      <div id="bestStats" class="stat">
        Best WPM: — · Best Accuracy: — · Fastest Time: — · Best Fairness (Blind): —
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div style="display:flex; align-items:center; gap:8px;">
      <strong>Session History</strong>
      <button id="exportBtn" class="right" title="Download CSV of attempts">Export CSV</button>
    </div>
    <div style="overflow:auto;">
      <table id="historyTable" aria-label="Session History">
        <thead>
          <tr>
            <th>Time</th>
            <th>Category</th>
            <th>Reference</th>
            <th>Mode</th>
            <th>Peeks</th>
            <th>Secs</th>
            <th>WPM</th>
            <th>Accuracy%</th>
            <th>Fairness%</th>
          </tr>
        </thead>
        <tbody id="historyBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // ========================================
    // Configuration
    // ========================================
    const LENGTH_THRESHOLDS = { shortMax: 110, mediumMax: 230 };
    const DEFAULT_PREVIEW_SECONDS = 10;
    const DEFAULT_PEEK_SECONDS = 5;

    // ========================================
    // Avatar definitions
    // ========================================
    const AVATARS = [
      { id: "moses", name: "Moses", src: "assets/avatars/moses-2d.png" },
      { id: "david", name: "David & Goliath", src: "assets/avatars/david-and-goliath-2d.png" },
      { id: "elijah", name: "Elijah", src: "assets/avatars/elijah-2d.png" },
      { id: "jonah", name: "Jonah", src: "assets/avatars/jonah-2d.png" },
      { id: "noahs-ark", name: "Noah's Ark", src: "assets/avatars/noahs-ark-2d.png" },
      { id: "burning-bush", name: "Burning Bush", src: "assets/avatars/burning-bush-2d.png" },
      { id: "ten-commandments", name: "Commandments", src: "assets/avatars/ten-commandments-2d.png" },
    ];

    // ========================================
    // DOM Element References
    // ========================================
    const elements = {
      category: document.getElementById("category"),
      length: document.getElementById("length"),
      version: document.getElementById("version"),
      blindToggle: document.getElementById("blindToggle"),
      previewSeconds: document.getElementById("previewSec"),
      peekSeconds: document.getElementById("peekSec"),
      previewLabel: document.getElementById("previewLabel"),
      peekLabel: document.getElementById("peekLabel"),
      categoryTitle: document.getElementById("categoryTitle"),
      newVerseButton: document.getElementById("newVerseBtn"),
      restartButton: document.getElementById("restartBtn"),
      meta: document.getElementById("meta"),
      banner: document.getElementById("banner"),
      typed: document.getElementById("typed"),
      incorrect: document.getElementById("incorrect"),
      remaining: document.getElementById("remaining"),
      hiddenMask: document.getElementById("hiddenMask"),
      input: document.getElementById("input"),
      blindFaithControls: document.getElementById("bfControls"),
      peekButton: document.getElementById("peekBtn"),
      finishButton: document.getElementById("finishBtn"),
      peekCount: document.getElementById("peekCount"),
      status: document.getElementById("status"),
      result: document.getElementById("result"),
      bestStats: document.getElementById("bestStats"),
      exportButton: document.getElementById("exportBtn"),
      historyBody: document.getElementById("historyBody"),
      copyline: document.getElementById("copyline"),
      avatarGrid: document.getElementById("avatarGrid"),
      raceAvatar: document.getElementById("raceAvatar"),
      racePct: document.getElementById("racePct"),
    };

    // ========================================
    // Application State
    // ========================================
    let state = {
      verseText: "",
      reference: "",
      actualCategory: "All",
      hideTimer: null,
      countdownTimer: null,
      peekTimer: null,
      peekCount: 0,
      started: false,
      startTime: 0,
      finished: false,
      totalKeystrokes: 0,
      errorKeystrokes: 0,
      errorPositions: new Set(),
      previousInputValue: "",
      bestWPM: null,
      bestAccuracy: null,
      fastestTime: null,
      bestFairness: null,
      history: [],
    };

    // ========================================
    // Avatar Functions
    // ========================================
    function getSelectedAvatar() {
      const savedAvatarId = localStorage.getItem("tof_avatar");
      return AVATARS.find(avatar => avatar.id === savedAvatarId) || AVATARS[0];
    }

    function renderAvatarGrid() {
      const selectedAvatar = getSelectedAvatar();
      elements.avatarGrid.innerHTML = "";

      for (const avatar of AVATARS) {
        const div = document.createElement("div");
        const isSelected = avatar.id === selectedAvatar.id;
        div.className = "avatar-option" + (isSelected ? " selected" : "");
        div.innerHTML = `<img src="${avatar.src}" alt="${avatar.name}" /><span>${avatar.name}</span>`;
        div.addEventListener("click", () => selectAvatar(avatar.id));
        elements.avatarGrid.appendChild(div);
      }
    }

    function selectAvatar(avatarId) {
      localStorage.setItem("tof_avatar", avatarId);
      renderAvatarGrid();
      elements.raceAvatar.src = getSelectedAvatar().src;
    }

    // ========================================
    // Race Track Functions
    // ========================================
    function updateRaceTrack() {
      const verseNormalized = normalizeQuotes(state.verseText);
      const typedNormalized = normalizeQuotes(elements.input.value || "");

      if (!verseNormalized.length) return;

      let correctCharCount = 0;
      for (let i = 0; i < typedNormalized.length; i++) {
        if (typedNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        } else {
          break;
        }
      }

      const progress = correctCharCount / verseNormalized.length;
      const percentComplete = Math.round(progress * 100);

      const trackLane = document.querySelector(".track-lane");
      const maxLeftPosition = trackLane.offsetWidth - elements.raceAvatar.offsetWidth;

      elements.raceAvatar.style.left = Math.round(progress * maxLeftPosition) + "px";
      elements.racePct.textContent = percentComplete + "%";
    }

    function resetRaceTrack() {
      elements.raceAvatar.style.transition = "none";
      elements.raceAvatar.style.left = "0";
      elements.racePct.textContent = "0%";
      requestAnimationFrame(() => {
        elements.raceAvatar.style.transition = "left 0.3s ease-out";
      });
    }

    // ========================================
    // Utility Functions
    // ========================================
    function normalizeQuotes(text) {
      return (text || "")
        .replace(/['\u2018\u2019\u201A\u201B]/g, "'")
        .replace(/["\u201C\u201D\u201E\u201F]/g, '"');
    }

    function normalizeForComparison(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function clampInteger(value, min, max) {
      const parsed = Math.floor(isFinite(value) ? value : min);
      return Math.min(max, Math.max(min, parsed));
    }

    function classifyVerseLength(text) {
      const length = text.trim().length;
      if (length <= LENGTH_THRESHOLDS.shortMax) return "short";
      if (length <= LENGTH_THRESHOLDS.mediumMax) return "medium";
      return "long";
    }

    function getCurrentCategoryLabel() {
      return elements.category.value === "all" ? "All" : titleCase(elements.category.value);
    }

    function getRandomVerseReference(category) {
      if (category && category !== "all") {
        const verseList = VERSE_CATEGORIES[category] || [];
        const reference = verseList[Math.floor(Math.random() * verseList.length)];
        return { reference, category };
      }

      const reference = ALL_REFERENCES[Math.floor(Math.random() * ALL_REFERENCES.length)];
      const foundCategory = REF_TO_CATEGORY[reference] || "all";
      return { reference, category: foundCategory };
    }

    // ========================================
    // Levenshtein Distance (for Blind Faith scoring)
    // ========================================
    function levenshteinDistance(stringA, stringB) {
      const lengthA = stringA.length;
      const lengthB = stringB.length;

      const matrix = Array.from({ length: lengthA + 1 }, () => new Array(lengthB + 1));

      for (let i = 0; i <= lengthA; i++) matrix[i][0] = i;
      for (let j = 0; j <= lengthB; j++) matrix[0][j] = j;

      for (let i = 1; i <= lengthA; i++) {
        for (let j = 1; j <= lengthB; j++) {
          const cost = stringA[i - 1] === stringB[j - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }

      return matrix[lengthA][lengthB];
    }

    function computeFairnessScore(groundTruth, attempt) {
      const normalizedTruth = normalizeForComparison(groundTruth);
      const normalizedAttempt = normalizeForComparison(attempt);

      if (!normalizedTruth.length) {
        return { scorePercent: 0, distance: 0, baseLength: 0 };
      }

      const distance = levenshteinDistance(normalizedTruth, normalizedAttempt);
      const score = Math.max(0, 1 - distance / normalizedTruth.length);

      return {
        scorePercent: Math.round(score * 100),
        distance,
        baseLength: normalizedTruth.length
      };
    }

    // ========================================
    // HTTP Request Utilities
    // ========================================
    function createTimeoutController(timeoutMs) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
      return {
        signal: controller.signal,
        cancel: () => clearTimeout(timeoutId)
      };
    }

    function classifyHttpError(error, response = null, bodyText = "") {
      const detail = (error && error.message) ? error.message : "";

      if (!response) {
        return {
          code: "NETWORK",
          userMessage: "Cannot reach the verse server.",
          hint: "If using FBV/ESV, start FastAPI (uvicorn server:app --reload --port 8000).",
          detail
        };
      }

      const status = response.status;

      if (status === 401) {
        return {
          code: "UNAUTHORIZED",
          userMessage: "The verse service rejected credentials.",
          hint: "Check API keys in .env / environment.",
          detail: bodyText
        };
      }

      if (status === 403) {
        return {
          code: "FORBIDDEN",
          userMessage: "This translation requires publisher permission.",
          hint: "Try KJV/WEB or an allowed version like FBV.",
          detail: bodyText
        };
      }

      if (status === 404) {
        return {
          code: "NOT_FOUND",
          userMessage: "No verse found for that reference.",
          hint: "Try a different verse or category.",
          detail: bodyText
        };
      }

      if (status === 502 || status === 503 || status === 504) {
        return {
          code: "UPSTREAM",
          userMessage: "Upstream provider unavailable.",
          hint: "Wait a moment and try again.",
          detail: bodyText
        };
      }

      return {
        code: "SERVER",
        userMessage: "The verse server hit an error.",
        hint: "Try again or switch to KJV/WEB.",
        detail: bodyText
      };
    }

    // ========================================
    // Verse Fetching
    // ========================================
    async function fetchViaProxy(reference, versionCode) {
      const baseUrl = "http://127.0.0.1:8000";
      const url = `${baseUrl}/verse?ref=${encodeURIComponent(reference)}&version=${encodeURIComponent(versionCode)}`;
      const { signal, cancel } = createTimeoutController(9000);

      try {
        const response = await fetch(url, { signal });
        const text = await response.text();

        if (!response.ok) {
          throw { isHttpError: true, response, text };
        }

        return JSON.parse(text);
      } catch (error) {
        const classified = error.isHttpError
          ? classifyHttpError(null, error.response, error.text)
          : classifyHttpError(error);
        const wrappedError = new Error(classified.userMessage);
        wrappedError.uiInfo = classified;
        throw wrappedError;
      } finally {
        cancel();
      }
    }

    async function fetchViaBibleApi(reference, versionCode) {
      const translation = (versionCode || "KJV").toLowerCase();
      const url = `https://bible-api.com/${encodeURIComponent(reference)}?translation=${encodeURIComponent(translation)}`;
      const { signal, cancel } = createTimeoutController(9000);

      try {
        const response = await fetch(url, { signal });
        const text = await response.text();

        if (!response.ok) {
          throw { isHttpError: true, response, text };
        }

        const data = JSON.parse(text);
        const verseText = Array.isArray(data.verses) && data.verses.length
          ? data.verses.map(verse => verse.text.trim()).join(" ")
          : (data.text || "");

        return {
          reference: data.reference || reference,
          text: verseText.replace(/\s+/g, " ").trim(),
          version: (versionCode || "KJV").toUpperCase(),
          fallback: true
        };
      } catch (error) {
        const classified = error.isHttpError
          ? classifyHttpError(null, error.response, error.text)
          : classifyHttpError(error);
        const wrappedError = new Error(classified.userMessage);
        wrappedError.uiInfo = classified;
        throw wrappedError;
      } finally {
        cancel();
      }
    }

    async function fetchVerseUnified(reference, versionCode) {
      try {
        return await fetchViaProxy(reference, versionCode);
      } catch (error) {
        const errorInfo = error.uiInfo || {};
        const publicVersions = ["KJV", "WEB"];

        if (publicVersions.includes(versionCode)) {
          showBanner("warn", `${errorInfo.userMessage || "Proxy unavailable."} Falling back to public provider for ${versionCode}...`);

          try {
            return await fetchViaBibleApi(reference, versionCode);
          } catch (fallbackError) {
            const fallbackInfo = fallbackError.uiInfo || {};
            showBanner("error", `${fallbackInfo.userMessage || "Failed to fetch verse."} ${fallbackInfo.hint ? "Hint: " + fallbackInfo.hint : ""}`);
            throw fallbackError;
          }
        }

        showBanner("error", `${errorInfo.userMessage || "Verse proxy error."} ${errorInfo.hint ? "Hint: " + errorInfo.hint : ""}`);
        throw error;
      }
    }

    async function fetchVerseMatchingLength(category, lengthPreference, versionCode) {
      if (lengthPreference === "any") {
        const pick = getRandomVerseReference(category);
        const result = await fetchVerseUnified(pick.reference, versionCode);
        return {
          reference: result.reference,
          text: result.text,
          category: REF_TO_CATEGORY[pick.reference] || category,
          copyright: result.copyright,
          version: result.version
        };
      }

      const MAX_ATTEMPTS = 8;
      let lastResult = null;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const pick = getRandomVerseReference(category);
        const result = await fetchVerseUnified(pick.reference, versionCode);
        const actualLength = classifyVerseLength(result.text);

        lastResult = {
          reference: result.reference,
          text: result.text,
          category: REF_TO_CATEGORY[pick.reference] || category,
          copyright: result.copyright,
          version: result.version
        };

        if (actualLength === lengthPreference) {
          return lastResult;
        }
      }

      return lastResult;
    }

    // ========================================
    // UI State Management
    // ========================================
    function setLoadingState(isLoading) {
      const buttons = [elements.newVerseButton, elements.restartButton, elements.peekButton, elements.finishButton].filter(Boolean);
      buttons.forEach(button => button.disabled = isLoading);
      elements.input.disabled = isLoading;

      if (isLoading) {
        elements.meta.textContent = "Loading verse...";
        showBanner("info", "Contacting verse providers...");
      } else if (/Contacting verse providers/.test(elements.banner.textContent)) {
        showBanner("info", "");
      }
    }

    function setTypingEnabled(enabled) {
      elements.input.readOnly = !enabled;
      elements.input.placeholder = enabled
        ? "Start typing the verse here..."
        : "Typing disabled while verse is visible (Blind Faith)";
    }

    function setBlindFaithUIVisible(visible) {
      elements.blindFaithControls.style.display = visible ? "flex" : "none";
      elements.previewLabel.style.display = visible ? "inline-flex" : "none";
      elements.peekLabel.style.display = visible ? "inline-flex" : "none";
      syncPeekButtonLabel();
    }

    function syncPeekButtonLabel() {
      const seconds = clampInteger(Number(elements.peekSeconds.value || DEFAULT_PEEK_SECONDS), 1, 10);
      if (elements.peekButton) {
        elements.peekButton.textContent = `Peek Verse (${seconds}s)`;
      }
    }

    // ========================================
    // Timer Utilities
    // ========================================
    function getPreviewMilliseconds() {
      const seconds = clampInteger(
        Number(elements.previewSeconds.value || localStorage.getItem("tof_preview_sec") || DEFAULT_PREVIEW_SECONDS),
        1,
        30
      );
      elements.previewSeconds.value = seconds;
      localStorage.setItem("tof_preview_sec", String(seconds));
      return seconds * 1000;
    }

    function getPeekMilliseconds() {
      const seconds = clampInteger(
        Number(elements.peekSeconds.value || localStorage.getItem("tof_peek_sec") || DEFAULT_PEEK_SECONDS),
        1,
        10
      );
      elements.peekSeconds.value = seconds;
      localStorage.setItem("tof_peek_sec", String(seconds));
      return seconds * 1000;
    }

    function clearAllTimers() {
      if (state.hideTimer) {
        clearTimeout(state.hideTimer);
        state.hideTimer = null;
      }
      if (state.peekTimer) {
        clearTimeout(state.peekTimer);
        state.peekTimer = null;
      }
      if (state.countdownTimer) {
        clearInterval(state.countdownTimer);
        state.countdownTimer = null;
      }
    }

    // ========================================
    // Verse Display Functions
    // ========================================
    function showVerse() {
      elements.hiddenMask.textContent = "";
      elements.typed.textContent = "";
      elements.incorrect.textContent = "";
      elements.remaining.textContent = state.verseText;

      if (elements.blindToggle.checked) {
        setTypingEnabled(false);
      }
    }

    function hideVerse() {
      elements.typed.textContent = "";
      elements.incorrect.textContent = "";
      elements.remaining.textContent = "";
      elements.hiddenMask.textContent = "— Verse hidden — type from memory —";

      if (elements.blindToggle.checked) {
        setTypingEnabled(true);
        elements.input.focus();
      }
    }

    function resetTypingArea(verseText, reference) {
      state.verseText = verseText;
      state.reference = reference;

      elements.typed.textContent = "";
      elements.incorrect.textContent = "";
      elements.remaining.textContent = state.verseText;
      elements.hiddenMask.textContent = "";

      elements.input.value = "";
      elements.input.classList.remove("error-state");
      elements.banner.textContent = "";
      elements.result.textContent = "—";
      elements.copyline.textContent = "";

      state.peekCount = 0;
      elements.peekCount.textContent = "0";

      state.started = false;
      state.startTime = 0;
      state.finished = false;
      state.totalKeystrokes = 0;
      state.errorKeystrokes = 0;
      state.errorPositions.clear();
      state.previousInputValue = "";

      updateLiveMetrics();
      resetRaceTrack();
      setTypingEnabled(true);
    }

    // ========================================
    // Blind Faith Mode
    // ========================================
    function startBlindPreviewCountdown() {
      const totalMs = getPreviewMilliseconds();
      let remainingMs = totalMs;

      showBanner("info", `Blind Faith: Memorise the verse... Hiding in ${Math.round(remainingMs / 1000)}s`);

      state.countdownTimer = setInterval(() => {
        remainingMs -= 1000;

        if (remainingMs <= 0) {
          clearInterval(state.countdownTimer);
          state.countdownTimer = null;
        } else {
          showBanner("info", `Blind Faith: Memorise the verse... Hiding in ${Math.round(remainingMs / 1000)}s`);
        }
      }, 1000);

      state.hideTimer = setTimeout(() => {
        hideVerse();
        showBanner("info", "Blind Faith: Type from memory. Use Peek if needed.");
        state.hideTimer = null;
      }, totalMs);
    }

    function handlePeek() {
      if (state.peekTimer) return;

      state.peekCount += 1;
      elements.peekCount.textContent = String(state.peekCount);

      showVerse();

      const peekDuration = getPeekMilliseconds();
      state.peekTimer = setTimeout(() => {
        hideVerse();
        state.peekTimer = null;
      }, peekDuration);
    }

    // ========================================
    // Metrics Calculation
    // ========================================
    function getElapsedSeconds() {
      if (!state.started) return 0;
      return (performance.now() - state.startTime) / 1000;
    }

    function computeLiveMetrics(currentTypedText) {
      const elapsedSeconds = getElapsedSeconds();
      const elapsedMinutes = elapsedSeconds / 60;

      const verseNormalized = normalizeQuotes(state.verseText);
      const typedNormalized = normalizeQuotes(currentTypedText || "");

      let correctCharCount = 0;
      for (let i = 0; i < typedNormalized.length; i++) {
        if (typedNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        }
      }

      const wordsPerMinute = elapsedMinutes > 0 ? (correctCharCount / 5) / elapsedMinutes : 0;
      const accuracy = state.totalKeystrokes > 0
        ? Math.max(0, 1 - (state.errorKeystrokes / state.totalKeystrokes))
        : 1;

      return {
        wpm: Math.round(wordsPerMinute),
        accuracyPercent: Math.round(accuracy * 100),
        timeSeconds: elapsedSeconds
      };
    }

    function updateLiveMetrics() {
      const metrics = computeLiveMetrics(elements.input.value || "");
      elements.status.textContent = `WPM: ${metrics.wpm} · Accuracy: ${metrics.accuracyPercent}% · Time: ${metrics.timeSeconds.toFixed(1)}s`;
    }

    // ========================================
    // History & Results
    // ========================================
    function addHistoryRow(entry) {
      const row = document.createElement("tr");
      const cells = [
        entry.timeLocal,
        entry.category,
        entry.reference,
        entry.mode,
        String(entry.peekCount),
        entry.seconds.toFixed(2),
        String(entry.wpm),
        String(entry.accuracyPercent),
        entry.fairnessPercent != null ? String(entry.fairnessPercent) : "—"
      ];

      for (const cellText of cells) {
        const cell = document.createElement("td");
        cell.textContent = cellText;
        row.appendChild(cell);
      }

      elements.historyBody.prepend(row);
    }

    function exportHistoryToCSV() {
      const headers = ["Time", "Category", "Reference", "Mode", "Peeks", "Seconds", "WPM", "AccuracyPct", "FairnessPct"];
      const rows = [headers.join(",")];

      for (const entry of state.history) {
        const row = [
          `"${entry.timeLocal.replace(/"/g, '""')}"`,
          `"${entry.category}"`,
          `"${entry.reference.replace(/"/g, '""')}"`,
          `"${entry.mode}"`,
          entry.peekCount,
          entry.seconds.toFixed(2),
          entry.wpm,
          entry.accuracyPercent,
          entry.fairnessPercent != null ? entry.fairnessPercent : ""
        ];
        rows.push(row.join(","));
      }

      const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = "type-of-faith-session.csv";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      URL.revokeObjectURL(url);
    }

    function finishAttempt(isBlindFinish = false) {
      if (state.finished) return;
      state.finished = true;

      const attempt = elements.input.value || "";
      const elapsedSeconds = getElapsedSeconds();
      const elapsedMinutes = elapsedSeconds / 60;

      const verseNormalized = normalizeQuotes(state.verseText);
      const attemptNormalized = normalizeQuotes(attempt);

      let correctCharCount = 0;
      for (let i = 0; i < attemptNormalized.length; i++) {
        if (attemptNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        }
      }

      const wordsPerMinute = elapsedMinutes > 0 ? Math.round((correctCharCount / 5) / elapsedMinutes) : 0;
      const accuracy = state.totalKeystrokes > 0
        ? Math.max(0, 1 - (state.errorKeystrokes / state.totalKeystrokes))
        : 1;
      const accuracyPercent = Math.round(accuracy * 100);

      let resultText = `Ref: ${state.reference} · Time: ${elapsedSeconds.toFixed(2)}s · WPM: ${wordsPerMinute} · Accuracy: ${accuracyPercent}%`;
      let fairnessPercent = null;

      if (elements.blindToggle.checked || isBlindFinish) {
        const fairnessResult = computeFairnessScore(state.verseText, attempt);
        fairnessPercent = fairnessResult.scorePercent;
        resultText += ` · Fairness: ${fairnessPercent}% · Peeks: ${state.peekCount}`;

        if (state.bestFairness === null || fairnessPercent > state.bestFairness) {
          state.bestFairness = fairnessPercent;
        }
      }

      elements.result.textContent = resultText;

      if (elements.blindToggle.checked) {
        showVerse();
        setTypingEnabled(false);
        showBanner("info", "Blind Faith: Verse revealed for review. Use Restart or New Verse when ready.");
      }

      // Update best stats
      if (state.bestWPM === null || wordsPerMinute > state.bestWPM) {
        state.bestWPM = wordsPerMinute;
      }
      if (state.bestAccuracy === null || accuracyPercent > state.bestAccuracy) {
        state.bestAccuracy = accuracyPercent;
      }
      if (state.fastestTime === null || elapsedSeconds < state.fastestTime) {
        state.fastestTime = elapsedSeconds;
      }

      elements.bestStats.textContent = `Best WPM: ${state.bestWPM ?? "—"} · Best Accuracy: ${state.bestAccuracy ?? "—"}% · Fastest Time: ${state.fastestTime ? state.fastestTime.toFixed(2) + "s" : "—"} · Best Fairness (Blind): ${state.bestFairness ?? "—"}%`;

      // Add to history
      const historyEntry = {
        timeLocal: new Date().toLocaleString(),
        category: titleCase(state.actualCategory),
        reference: state.reference,
        mode: elements.blindToggle.checked ? "Blind" : "Normal",
        peekCount: state.peekCount,
        seconds: elapsedSeconds,
        wpm: wordsPerMinute,
        accuracyPercent,
        fairnessPercent
      };

      state.history.push(historyEntry);
      addHistoryRow(historyEntry);
    }

    // ========================================
    // Main Verse Loading
    // ========================================
    async function loadRandomVerse() {
      clearAllTimers();
      setLoadingState(true);

      const category = elements.category.value;
      const lengthPreference = elements.length.value;
      const versionCode = (elements.version.value || "KJV").toUpperCase();

      elements.meta.textContent = "Loading verse...";
      elements.copyline.textContent = "";
      elements.categoryTitle.textContent = getCurrentCategoryLabel();

      try {
        const result = await fetchVerseMatchingLength(category, lengthPreference, versionCode);

        if (!result || !result.text) {
          throw new Error("Empty verse text");
        }

        showBanner("success", "Verse loaded. Happy typing!");
        resetTypingArea(result.text, result.reference);

        state.actualCategory = result.category || category;
        elements.categoryTitle.textContent = titleCase(state.actualCategory);

        const isBlindMode = elements.blindToggle.checked;
        setBlindFaithUIVisible(isBlindMode);

        if (isBlindMode) {
          showVerse();
          startBlindPreviewCountdown();
        } else {
          setTypingEnabled(true);
          showVerse();
          elements.banner.style.display = "none";
        }

        const lengthClass = classifyVerseLength(result.text);
        const fallbackNote = result.fallback ? " · (fallback source)" : "";
        elements.meta.textContent = `${state.reference} (${(result.version || versionCode).toUpperCase()}) · ${titleCase(lengthClass)}${fallbackNote}`;

        if (result.copyright) {
          elements.copyline.textContent = result.copyright;
        }
      } catch (error) {
        const errorInfo = error.uiInfo || {};
        showBanner("error", `${errorInfo.userMessage || "Could not load verse."} ${errorInfo.hint ? "Hint: " + errorInfo.hint : ""}`);
        console.error("Verse load failed:", errorInfo.detail || error);
      } finally {
        setLoadingState(false);

        // Focus input after loading completes (when not in blind mode)
        if (!elements.blindToggle.checked) {
          elements.input.focus();
        }
      }
    }

    function restartCurrentVerse() {
      clearAllTimers();
      resetTypingArea(state.verseText, state.reference);
      elements.categoryTitle.textContent = titleCase(state.actualCategory);

      const isBlindMode = elements.blindToggle.checked;
      setBlindFaithUIVisible(isBlindMode);

      if (isBlindMode) {
        showVerse();
        startBlindPreviewCountdown();
      } else {
        setTypingEnabled(true);
        showVerse();
        elements.input.focus();
      }
    }

    // ========================================
    // Input Handling
    // ========================================
    elements.input.addEventListener("input", () => {
      const currentValue = elements.input.value;
      const verseNormalized = normalizeQuotes(state.verseText);
      const currentNormalized = normalizeQuotes(currentValue);
      const previousNormalized = normalizeQuotes(state.previousInputValue);

      // Block typing if blind mode and verse is still visible
      if (elements.blindToggle.checked && elements.remaining.textContent.length > 0) {
        setTypingEnabled(false);
        elements.input.value = state.previousInputValue;
        return;
      }

      // Track keystrokes for accuracy calculation
      if (currentValue.length > state.previousInputValue.length) {
        const addedChars = currentNormalized.slice(previousNormalized.length);

        for (let i = 0; i < addedChars.length; i++) {
          const charIndex = previousNormalized.length + i;
          const typedChar = addedChars[i];

          state.totalKeystrokes++;
          if (typedChar !== verseNormalized[charIndex]) {
            state.errorKeystrokes++;
            state.errorPositions.add(charIndex); // Track position where error occurred
          }
        }
      }

      state.previousInputValue = currentValue;

      // Start timer on first keystroke
      if (!state.started && currentValue.length > 0) {
        state.started = true;
        state.startTime = performance.now();
      }

      updateLiveMetrics();
      updateRaceTrack();

      // Find the first error position
      let correctCharCount = 0;
      for (let i = 0; i < currentNormalized.length; i++) {
        if (currentNormalized[i] === verseNormalized[i]) {
          correctCharCount++;
        } else {
          break;
        }
      }

      const hasError = correctCharCount < currentValue.length;
      const errorCharCount = currentValue.length - correctCharCount;

      const isBlindMode = elements.blindToggle.checked;
      const isVerseVisible = elements.remaining.textContent.length > 0 || elements.hiddenMask.textContent.length === 0;

      if (!isBlindMode || isVerseVisible) {
        // Update verse display: correct (green), corrected (yellow), incorrect (red), remaining (muted)
        let typedHtml = '';
        for (let k = 0; k < correctCharCount; k++) {
          if (state.errorPositions.has(k)) {
            typedHtml += `<span class="corrected">${state.verseText[k]}</span>`;
          } else {
            typedHtml += state.verseText[k];
          }
        }
        elements.typed.innerHTML = typedHtml;
        elements.incorrect.textContent = state.verseText.substring(correctCharCount, correctCharCount + errorCharCount);
        elements.remaining.textContent = state.verseText.substring(correctCharCount + errorCharCount);

        // Update input error state
        if (hasError) {
          elements.input.classList.add("error-state");
        } else {
          elements.input.classList.remove("error-state");
        }

        // Check for completion
        if (currentValue.length === state.verseText.length && !hasError) {
          finishAttempt(false);
        }
      } else {
        // Blind mode with verse hidden - just update input state
        if (hasError) {
          elements.input.classList.add("error-state");
        } else {
          elements.input.classList.remove("error-state");
        }
      }
    });

    // ========================================
    // Event Listeners
    // ========================================
    elements.newVerseButton.addEventListener("click", loadRandomVerse);
    elements.restartButton.addEventListener("click", restartCurrentVerse);
    elements.category.addEventListener("change", loadRandomVerse);
    elements.length.addEventListener("change", loadRandomVerse);
    elements.version.addEventListener("change", loadRandomVerse);

    elements.blindToggle.addEventListener("change", () => {
      setBlindFaithUIVisible(elements.blindToggle.checked);
      loadRandomVerse();
    });

    elements.previewSeconds.addEventListener("change", () => getPreviewMilliseconds());
    elements.peekSeconds.addEventListener("change", () => {
      getPeekMilliseconds();
      syncPeekButtonLabel();
    });

    if (elements.peekButton) {
      elements.peekButton.addEventListener("click", handlePeek);
    }

    if (elements.finishButton) {
      elements.finishButton.addEventListener("click", () => finishAttempt(true));
    }

    elements.exportButton.addEventListener("click", exportHistoryToCSV);

    // Keyboard shortcuts
    document.addEventListener("keydown", (event) => {
      if (event.ctrlKey && event.key === "Enter") {
        event.preventDefault();
        finishAttempt(true);
      } else if (event.ctrlKey && event.key.toLowerCase() === "p") {
        event.preventDefault();
        handlePeek();
      } else if (event.ctrlKey && event.key.toLowerCase() === "r") {
        event.preventDefault();
        restartCurrentVerse();
      } else if (event.ctrlKey && event.key.toLowerCase() === "m") {
        event.preventDefault();
        loadRandomVerse();
      } else if (event.ctrlKey && event.key.toLowerCase() === "j") {
        event.preventDefault();
        const themeModes = ["auto", "light", "dark"];
        const currentTheme = localStorage.getItem(THEME_KEY) || "auto";
        const nextIndex = (themeModes.indexOf(currentTheme) + 1) % themeModes.length;
        applyTheme(themeModes[nextIndex]);
      }
    });

    // ========================================
    // Initialization
    // ========================================
    (async () => {
      initTheme();
      renderAvatarGrid();
      elements.raceAvatar.src = getSelectedAvatar().src;

      elements.previewSeconds.value = localStorage.getItem("tof_preview_sec") ?? DEFAULT_PREVIEW_SECONDS;
      elements.peekSeconds.value = localStorage.getItem("tof_peek_sec") ?? DEFAULT_PEEK_SECONDS;
      syncPeekButtonLabel();
      setBlindFaithUIVisible(elements.blindToggle.checked);

      elements.categoryTitle.textContent = getCurrentCategoryLabel();

      // Check if proxy is available
      try {
        const response = await fetch("http://127.0.0.1:8000/health", { cache: "no-store" });
        if (!response.ok) throw new Error("Proxy offline");
      } catch {
        showBanner("warn", "Proxy offline. KJV/WEB will fall back to public provider. Start FastAPI for FBV/ESV.");
      }

      // Load initial verse
      await loadRandomVerse();
    })();
  </script>
</body>
</html>
