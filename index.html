<!DOCTYPE html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <title>Type of Faith MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%93%96%3C/text%3E%3C/svg%3E">
  <link rel="stylesheet" href="shared/nav.css" />
  <style>
    /* ---------- Light theme (default) ---------- */
    :root {
      --bg:#faf8f5; --ink:#111; --muted:#555;
      --ok:#0a7a0a; --err:#b00020; --accent:#8b6b3b;
      --panel:#fff; --border:#eee;
      --banner-bg:#fff7e6; --link:#1a56db;
      --input-border:#ddd; --btn-border:#ccc;
    }
    /* ---------- Dark theme overrides ---------- */
    :root[data-theme="dark"] {
      --bg:#0f1115; --ink:#e6e6e6; --muted:#a8a8a8;
      --ok:#6ee7a0; --err:#ff6b81; --accent:#d7c3a0;
      --panel:#151922; --border:#2a2f3a;
      --banner-bg:#1d2430; --link:#87b3ff;
      --input-border:#2b3240; --btn-border:#3a4252;
    }

    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--ink); margin: 24px; }
    a { color: var(--link); }
    h2 { margin: 8px 0 16px; font-weight: 600; color: var(--ink); }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    select, button, label, input[type="number"] { font-size: 16px; }
    select, button, input[type="number"] { padding: 8px 10px; }
    input[type="number"] { width: 80px; background: var(--panel); color: var(--ink); border: 1px solid var(--input-border); border-radius: 6px; }
    button { cursor: pointer; border: 1px solid var(--btn-border); background: var(--panel); color: var(--ink); border-radius: 6px; }
    button:active { transform: translateY(1px); }
    .toggle { display: inline-flex; gap: 8px; align-items: center; }
    #meta { font-size: 14px; color: var(--muted); margin-bottom: 4px; }
    #banner { font-size: 14px; color: var(--accent); margin: 6px 0 10px; padding: 6px 8px; border-radius: 6px; background: var(--banner-bg); display:none; }
    #verse { font-size: 20px; line-height: 1.6; margin-bottom: 6px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; min-height: 3.5em; }
    #typed { color: var(--ok); }
    #remaining { color: var(--muted); }
    #hiddenMask { color: var(--muted); font-style: italic; }
    #input { width: 100%; font-size: 20px; padding: 10px 12px; border-radius: 8px; border: 1px solid var(--input-border); background: var(--panel); color: var(--ink); }
    .bf-controls { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    .right { margin-left: auto; }
    .panels { display: grid; gap: 12px; grid-template-columns: 1fr; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 12px; }
    .stat { font-variant-numeric: tabular-nums; }
    #status { font-size: 14px; color: var(--muted); }
    #result { font-size: 16px; }
    #bestStats { font-size: 14px; }
    #peekCount { font-weight: 600; }
    .hint { font-size: 12px; color: var(--muted); }
    .copyline { font-size: 12px; color: var(--muted); margin: 6px 0 8px; }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid var(--border); }
    th { background: color-mix(in srgb, var(--panel) 60%, var(--border)); }
    @media (min-width: 1000px) { .panels { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <script src="shared/data.js"></script>
  <script src="shared/nav.js"></script>
  <script src="shared/theme.js"></script>

  <div class="controls">
    <label>
      Category:
      <select id="category">
        <option value="all">All</option>
        <option value="anger">Anger</option>
        <option value="anxiety">Anxiety</option>
        <option value="courage">Courage</option>
        <option value="depression">Depression</option>
        <option value="doubt">Doubt</option>
        <option value="faith">Faith</option>
        <option value="fear">Fear</option>
        <option value="forgiveness">Forgiveness</option>
        <option value="healing">Healing</option>
        <option value="hope">Hope</option>
        <option value="jealousy">Jealousy</option>
        <option value="joy">Joy</option>
        <option value="loss">Loss</option>
        <option value="love">Love</option>
        <option value="patience">Patience</option>
        <option value="peace">Peace</option>
        <option value="pride">Pride</option>
        <option value="stress">Stress</option>
        <option value="temptation">Temptation</option>
        <option value="wisdom">Wisdom</option>
      </select>
    </label>

    <label>
      Verse length:
      <select id="length">
        <option value="any">Any</option>
        <option value="short">Short</option>
        <option value="medium">Medium</option>
        <option value="long">Long</option>
      </select>
    </label>

    <label>
      Version:
      <select id="version">
        <option value="KJV">KJV (bible-api.com)</option>
        <option value="WEB">WEB (World English Bible)</option>
        <option value="FBV">FBV (api.bible via proxy)</option>
        <option value="ESV">ESV (Crossway API via proxy)</option>
      </select>
    </label>

    <label class="toggle" title="Show verse briefly, then hide it so you type from memory">
      <input type="checkbox" id="blindToggle" />
      Blind Faith
    </label>

    <label id="previewLabel" class="toggle" title="Initial visible time before hiding (1-30s)" style="display:none">
      Preview (s):
      <input id="previewSec" type="number" min="1" max="30" step="1" />
    </label>

    <label id="peekLabel" class="toggle" title="Peek reveal time (1-10s)" style="display:none">
      Peek (s):
      <input id="peekSec" type="number" min="1" max="10" step="1" />
    </label>

    <button id="newVerseBtn" title="Ctrl+M">New Verse</button>
    <button id="restartBtn" title="Restart this verse (Ctrl+R)">Restart</button>
  </div>

  <h2 id="categoryTitle">All</h2>

  <div id="meta"></div>
  <div id="banner"></div>

  <div id="verse">
    <span id="typed"></span><span id="remaining"></span><span id="hiddenMask"></span>
  </div>

  <div class="copyline" id="copyline"></div>

  <div class="bf-controls" id="bfControls" style="display:none;">
    <button id="peekBtn" title="Reveal the verse (Ctrl+P)">Peek Verse</button>
    <button id="finishBtn" title="Calculate your fairness score (Ctrl+Enter)">Finish Attempt</button>
    <span>Peeks used: <span id="peekCount">0</span></span>
    <span class="hint right">Shortcuts: Ctrl+P peek · Ctrl+Enter finish · Ctrl+R restart · Ctrl+M new</span>
  </div>

  <input id="input" placeholder="Start typing the verse here..." autocomplete="off" spellcheck="false" />

  <div class="panels">
    <div class="card">
      <strong>Live Metrics</strong>
      <div id="status" class="stat">WPM: 0 · Accuracy: 100% · Time: 0.0s</div>
    </div>
    <div class="card">
      <strong>Result</strong>
      <div id="result" class="stat">—</div>
    </div>
    <div class="card" style="grid-column: 1 / -1;">
      <strong>Best of Session</strong>
      <div id="bestStats" class="stat">
        Best WPM: — · Best Accuracy: — · Fastest Time: — · Best Fairness (Blind): —
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div style="display:flex; align-items:center; gap:8px;">
      <strong>Session History</strong>
      <button id="exportBtn" class="right" title="Download CSV of attempts">Export CSV</button>
    </div>
    <div style="overflow:auto;">
      <table id="historyTable" aria-label="Session History">
        <thead>
          <tr>
            <th>Time</th>
            <th>Category</th>
            <th>Reference</th>
            <th>Mode</th>
            <th>Peeks</th>
            <th>Secs</th>
            <th>WPM</th>
            <th>Accuracy%</th>
            <th>Fairness%</th>
          </tr>
        </thead>
        <tbody id="historyBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // ======= Config / defaults =======
    const LEN_THRESHOLDS = { shortMax: 110, mediumMax: 230 };
    const DEFAULT_PREVIEW_SEC = 10;
    const DEFAULT_PEEK_SEC = 5;

    // ======= DOM refs =======
    const categoryEl = document.getElementById("category");
    const lengthEl = document.getElementById("length");
    const versionEl = document.getElementById("version");
    const blindToggleEl = document.getElementById("blindToggle");
    const previewSecEl = document.getElementById("previewSec");
    const peekSecEl = document.getElementById("peekSec");
    const previewLabelEl = document.getElementById("previewLabel");
    const peekLabelEl = document.getElementById("peekLabel");
    const categoryTitleEl = document.getElementById("categoryTitle");
    const newVerseBtn = document.getElementById("newVerseBtn");
    const restartBtn = document.getElementById("restartBtn");
    const metaEl = document.getElementById("meta");
    const bannerEl = document.getElementById("banner");
    const typedEl = document.getElementById("typed");
    const remainingEl = document.getElementById("remaining");
    const hiddenMaskEl = document.getElementById("hiddenMask");
    const inputEl = document.getElementById("input");
    const bfControlsEl = document.getElementById("bfControls");
    const peekBtn = document.getElementById("peekBtn");
    const finishBtn = document.getElementById("finishBtn");
    const peekCountEl = document.getElementById("peekCount");
    const statusEl = document.getElementById("status");
    const resultEl = document.getElementById("result");
    const bestStatsEl = document.getElementById("bestStats");
    const exportBtn = document.getElementById("exportBtn");
    const historyBody = document.getElementById("historyBody");
    const copylineEl = document.getElementById("copyline");

    // ======= State =======
    let verseText = "";
    let reference = "";
    let actualCategory = "All";
    let hideTimer = null, countdownTimer = null, peekTimer = null, peekCount = 0;
    let started = false, startTime = 0, finished = false;
    let totalKeystrokes = 0, errorKeystrokes = 0, prevValue = "";
    let bestWPM = null, bestAccuracy = null, fastestTime = null, bestFairness = null;
    const history = [];

    // ======= UI helpers =======
    function setLoading(isLoading) {
      const btns = [newVerseBtn, restartBtn, peekBtn, finishBtn].filter(Boolean);
      btns.forEach(b => b.disabled = !!isLoading);
      inputEl.disabled = !!isLoading;
      if (isLoading) { metaEl.textContent = "Loading verse..."; showBanner("info", "Contacting verse providers..."); }
      else if (/Contacting verse providers/.test(bannerEl.textContent)) showBanner("info", "");
    }
    function withTimeout(ms) { const ctrl = new AbortController(); const t = setTimeout(() => ctrl.abort(), ms); return { signal: ctrl.signal, cancel: () => clearTimeout(t) }; }
    function clampInt(n, min, max){ n = Math.floor(isFinite(n) ? n : min); return Math.min(max, Math.max(min, n)); }
    function classifyError(err, res=null, bodyText="") {
      const detail = (err && err.message) ? err.message : "";
      if (!res) return { code:"NETWORK", user:"Cannot reach the verse server.", hint:"If using FBV/ESV, start FastAPI (uvicorn server:app --reload --port 8000).", detail };
      const s = res.status;
      if (s===401) return { code:"UNAUTHORIZED", user:"The verse service rejected credentials.", hint:"Check API keys in .env / environment.", detail: bodyText };
      if (s===403) return { code:"FORBIDDEN", user:"This translation requires publisher permission.", hint:"Try KJV/WEB or an allowed version like FBV.", detail: bodyText };
      if (s===404) return { code:"NOT_FOUND", user:"No verse found for that reference.", hint:"Try a different verse or category.", detail: bodyText };
      if (s===502 || s===503 || s===504) return { code:"UPSTREAM", user:"Upstream provider unavailable.", hint:"Wait a moment and try again.", detail: bodyText };
      return { code:"SERVER", user:"The verse server hit an error.", hint:"Try again or switch to KJV/WEB.", detail: bodyText };
    }
    const currentCategorySelectionLabel = () => (categoryEl.value === "all" ? "All" : titleCase(categoryEl.value));
    function getRandomRefAndCategory(category) {
      if (category && category !== "all") {
        const list = VERSE_CATEGORIES[category] || [];
        const ref = list[Math.floor(Math.random() * list.length)];
        return { ref, cat: category };
      }
      const ref = ALL_REFERENCES[Math.floor(Math.random() * ALL_REFERENCES.length)];
      const cat = REF_TO_CATEGORY[ref] || "all";
      return { ref, cat };
    }
    function classifyLengthByChars(text) {
      const len = text.trim().length;
      if (len <= LEN_THRESHOLDS.shortMax) return "short";
      if (len <= LEN_THRESHOLDS.mediumMax) return "medium";
      return "long";
    }
    function normalizeQuotes(s){ return (s||"").replace(/['\u2018\u2019\u201A\u201B]/g,"'").replace(/["\u201C\u201D\u201E\u201F]/g,'"'); }
    function normalize(s){ return s.toLowerCase().replace(/[^a-z0-9\s]/g,"").replace(/\s+/g," ").trim(); }
    function levenshtein(a,b){
      const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>new Array(n+1));
      for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j;
      for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const c=a[i-1]===b[j-1]?0:1; dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+c); } }
      return dp[m][n];
    }
    function computeFairnessScore(groundTruth,attempt){
      const g=normalize(groundTruth), t=normalize(attempt);
      if(!g.length) return {scorePct:0,distance:0,baseLen:0};
      const dist=levenshtein(g,t); const score=Math.max(0,1-dist/g.length);
      return {scorePct:Math.round(score*100),distance:dist,baseLen:g.length};
    }
    function setTypingEnabled(on) {
      inputEl.readOnly = !on;
      inputEl.placeholder = on ? "Start typing the verse here..." : "Typing disabled while verse is visible (Blind Faith)";
    }
    function getPreviewMs() {
      const n = clampInt(Number(previewSecEl.value || localStorage.getItem("tof_preview_sec") || DEFAULT_PREVIEW_SEC), 1, 30);
      previewSecEl.value = n; localStorage.setItem("tof_preview_sec", String(n));
      return n * 1000;
    }
    function getPeekMs() {
      const n = clampInt(Number(peekSecEl.value || localStorage.getItem("tof_peek_sec") || DEFAULT_PEEK_SEC), 1, 10);
      peekSecEl.value = n; localStorage.setItem("tof_peek_sec", String(n));
      return n * 1000;
    }
    function syncPeekButtonLabel(){ const secs = clampInt(Number(peekSecEl.value || DEFAULT_PEEK_SEC), 1, 10); if (peekBtn) peekBtn.textContent = `Peek Verse (${secs}s)`; }

    // ======= Providers =======
    async function fetchViaProxy(ref, versionCode) {
      const base = "http://127.0.0.1:8000";
      const url = `${base}/verse?ref=${encodeURIComponent(ref)}&version=${encodeURIComponent(versionCode)}`;
      const { signal, cancel } = withTimeout(9000);
      try { const res = await fetch(url, { signal }); const text = await res.text(); if (!res.ok) throw { __http: true, res, text }; return JSON.parse(text); }
      catch (e) { const c = e.__http ? classifyError(null, e.res, e.text) : classifyError(e); const err = new Error(c.user); err._ui=c; throw err; }
      finally { cancel(); }
    }
    async function fetchViaBibleApi(ref, versionCode) {
      const t = (versionCode || "KJV").toLowerCase();
      const url = `https://bible-api.com/${encodeURIComponent(ref)}?translation=${encodeURIComponent(t)}`;
      const { signal, cancel } = withTimeout(9000);
      try {
        const res = await fetch(url, { signal }); const text = await res.text();
        if (!res.ok) throw { __http: true, res, text };
        const data = JSON.parse(text);
        const verseText = Array.isArray(data.verses) && data.verses.length ? data.verses.map(v => v.text.trim()).join(" ") : (data.text || "");
        return { reference: data.reference || ref, text: verseText.replace(/\s+/g, " ").trim(), version: (versionCode || "KJV").toUpperCase(), fallback: true };
      } catch (e) { const c = e.__http ? classifyError(null, e.res, e.text) : classifyError(e); const err = new Error(c.user); err._ui=c; throw err; }
      finally { cancel(); }
    }
    async function fetchVerseUnified(ref, versionCode) {
      try { return await fetchViaProxy(ref, versionCode); }
      catch (e) {
        const info = e._ui || {}; const pub = ["KJV","WEB"];
        if (pub.includes(versionCode)) {
          showBanner("warn", `${info.user || "Proxy unavailable."} Falling back to public provider for ${versionCode}...`);
          try { return await fetchViaBibleApi(ref, versionCode); }
          catch (e2) { const i2 = e2._ui || {}; showBanner("error", `${i2.user || "Failed to fetch verse."} ${i2.hint ? "Hint: "+i2.hint : ""}`); throw e2; }
        }
        showBanner("error", `${info.user || "Verse proxy error."} ${info.hint ? "Hint: "+info.hint : ""}`); throw e;
      }
    }

    // ======= Flow helpers =======
    function clearTimers() {
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
      if (peekTimer) { clearTimeout(peekTimer); peekTimer = null; }
      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    }
    function resetTypingArea(text, ref) {
      verseText = text; reference = ref;
      typedEl.textContent = ""; remainingEl.textContent = verseText; hiddenMaskEl.textContent = "";
      inputEl.value = ""; inputEl.style.color = "black"; bannerEl.textContent = ""; resultEl.textContent = "—"; copylineEl.textContent = "";
      peekCount = 0; peekCountEl.textContent = "0";
      started = false; startTime = 0; finished = false;
      totalKeystrokes = 0; errorKeystrokes = 0; prevValue = "";
      updateLiveMetrics(); inputEl.focus(); setTypingEnabled(true);
    }
    function setBlindFaithUI(active) {
      bfControlsEl.style.display = active ? "flex" : "none";
      previewLabelEl.style.display = active ? "inline-flex" : "none";
      peekLabelEl.style.display = active ? "inline-flex" : "none";
      syncPeekButtonLabel();
    }
    function startBlindPreviewThenHide() {
      let total = getPreviewMs();
      let msLeft = total;
      showBanner("info", `Blind Faith: Memorise the verse... Hiding in ${(msLeft/1000).toFixed(0)}s`);
      countdownTimer = setInterval(() => {
        msLeft -= 1000;
        if (msLeft <= 0) { clearInterval(countdownTimer); countdownTimer = null; }
        else { showBanner("info", `Blind Faith: Memorise the verse... Hiding in ${(msLeft/1000).toFixed(0)}s`); }
      }, 1000);
      hideTimer = setTimeout(() => { hideVerse(); showBanner("info", "Blind Faith: Type from memory. Use Peek if needed."); hideTimer = null; }, total);
    }
    function showVerse() { hiddenMaskEl.textContent = ""; typedEl.textContent = ""; remainingEl.textContent = verseText; if (blindToggleEl.checked) setTypingEnabled(false); }
    function hideVerse() { typedEl.textContent = ""; remainingEl.textContent = ""; hiddenMaskEl.textContent = "— Verse hidden — type from memory —"; if (blindToggleEl.checked) { setTypingEnabled(true); inputEl.focus(); } }
    function handlePeek() { if (peekTimer) return; peekCount += 1; peekCountEl.textContent = String(peekCount); showVerse(); const ms = getPeekMs(); peekTimer = setTimeout(() => { hideVerse(); peekTimer = null; }, ms); }

    // ======= Metrics & history =======
    function getElapsedSeconds(){ return !started?0:(performance.now()-startTime)/1000; }
    function computeLiveMetrics(currentTyped){
      const elapsedSec=getElapsedSeconds(), minutes=elapsedSec/60;
      const vtNorm = normalizeQuotes(verseText);
      const ctNorm = normalizeQuotes(currentTyped||"");
      let correctChars=0;
      for(let i=0;i<ctNorm.length;i++){ if(ctNorm[i]===vtNorm[i]) correctChars++; }
      const grossWPM=minutes>0?((correctChars/5)/minutes):0;
      const acc= totalKeystrokes>0? Math.max(0,1-(errorKeystrokes/totalKeystrokes)) : 1;
      return { wpm: Math.round(grossWPM), accuracy: Math.round(acc*100), timeSec: elapsedSec };
    }
    function updateLiveMetrics(){ const { wpm, accuracy, timeSec } = computeLiveMetrics(inputEl.value||""); statusEl.textContent = `WPM: ${wpm} · Accuracy: ${accuracy}% · Time: ${timeSec.toFixed(1)}s`; }
    function addHistoryRow(e){ const tr=document.createElement("tr"); const cells=[e.timeLocal,e.category,e.reference,e.mode,String(e.peeks),e.seconds.toFixed(2),String(e.wpm),String(e.accuracyPct),(e.fairnessPct!=null?String(e.fairnessPct):"—")]; for(const c of cells){ const td=document.createElement("td"); td.textContent=c; tr.appendChild(td); } historyBody.prepend(tr); }
    function exportCSV(){ const header=["Time","Category","Reference","Mode","Peeks","Seconds","WPM","AccuracyPct","FairnessPct"]; const rows=[header.join(",")]; for(const e of history){ const row=[`"${e.timeLocal.replace(/"/g,'""')}"`,`"${e.category}"`,`"${e.reference.replace(/"/g,'""')}"`,`"${e.mode}"`,e.peeks,e.seconds.toFixed(2),e.wpm,e.accuracyPct,(e.fairnessPct!=null?e.fairnessPct:"")]; rows.push(row.join(",")); } const blob=new Blob([rows.join("\n")],{type:"text/csv;charset=utf-8"}); const url=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=url; a.download="type-of-faith-session.csv"; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
    function finishAttempt(isBlindFinish=false){
      if(finished) return; finished=true;
      const attempt=inputEl.value||""; const elapsedSec=getElapsedSeconds(); const minutes=elapsedSec/60;
      let correctChars=0; const vtNorm=normalizeQuotes(verseText); const atNorm=normalizeQuotes(attempt);
      for(let i=0;i<atNorm.length;i++){ if(atNorm[i]===vtNorm[i]) correctChars++; }
      const grossWPM=minutes>0?Math.round(((correctChars/5)/minutes)):0;
      const acc= totalKeystrokes>0? Math.max(0,1-(errorKeystrokes/totalKeystrokes)) : 1;
      const accuracyPct=Math.round(acc*100);
      let result=`Ref: ${reference} · Time: ${elapsedSec.toFixed(2)}s · WPM: ${grossWPM} · Accuracy: ${accuracyPct}%`;
      let fairnessPct=null;
      if(blindToggleEl.checked||isBlindFinish){ const {scorePct}=computeFairnessScore(verseText,attempt); fairnessPct=scorePct; result+=` · Fairness: ${fairnessPct}% · Peeks: ${peekCount}`; if(bestFairness===null||fairnessPct>bestFairness) bestFairness=fairnessPct; }
      resultEl.textContent=result;
      if(blindToggleEl.checked){ showVerse(); setTypingEnabled(false); showBanner("info", "Blind Faith: Verse revealed for review. Use Restart or New Verse when ready."); }
      if(bestWPM===null||grossWPM>bestWPM) bestWPM=grossWPM;
      if(bestAccuracy===null||accuracyPct>bestAccuracy) bestAccuracy=accuracyPct;
      if(fastestTime===null||elapsedSec<fastestTime) fastestTime=elapsedSec;
      bestStatsEl.textContent=`Best WPM: ${bestWPM??"—"} · Best Accuracy: ${bestAccuracy??"—"}% · Fastest Time: ${fastestTime?fastestTime.toFixed(2)+"s":"—"} · Best Fairness (Blind): ${bestFairness??"—"}%`;
      const entry={ timeLocal:new Date().toLocaleString(), category:titleCase(actualCategory), reference, mode:(blindToggleEl.checked?"Blind":"Normal"), peeks:peekCount, seconds:elapsedSec, wpm:grossWPM, accuracyPct, fairnessPct };
      history.push(entry); addHistoryRow(entry);
    }

    // ======= Verse selection =======
    async function fetchVerseMatchingLength(category, lengthPref, versionCode){
      if(lengthPref==="any"){
        const pick=getRandomRefAndCategory(category);
        const got=await fetchVerseUnified(pick.ref, versionCode);
        return { reference: got.reference, text: got.text, cat: REF_TO_CATEGORY[pick.ref] || category, copyright: got.copyright, version: got.version };
      }
      const MAX_TRIES=8; let last=null;
      for(let i=0;i<MAX_TRIES;i++){
        const pick=getRandomRefAndCategory(category);
        const got=await fetchVerseUnified(pick.ref, versionCode);
        const cls=classifyLengthByChars(got.text);
        last={ reference: got.reference, text: got.text, cat: REF_TO_CATEGORY[pick.ref] || category, copyright: got.copyright, version: got.version };
        if(cls===lengthPref) return last;
      }
      return last;
    }

    async function loadRandomVerseForSelection(){
      clearTimers();
      setLoading(true);
      const category=categoryEl.value;
      const lenPref=lengthEl.value;
      const versionCode=(versionEl.value||"KJV").toUpperCase();
      metaEl.textContent="Loading verse..."; copylineEl.textContent="";
      categoryTitleEl.textContent=currentCategorySelectionLabel();
      try{
        const got=await fetchVerseMatchingLength(category,lenPref,versionCode);
        if(!got||!got.text) throw new Error("Empty verse text");
        showBanner("success","Verse loaded. Happy typing!");
        resetTypingArea(got.text, got.reference);
        actualCategory=got.cat||category; categoryTitleEl.textContent=titleCase(actualCategory);
        const blindActive=blindToggleEl.checked; setBlindFaithUI(blindActive);
        if(blindActive){ showVerse(); startBlindPreviewThenHide(); } else { setTypingEnabled(true); showVerse(); bannerEl.textContent=""; }
        const cls=classifyLengthByChars(got.text);
        metaEl.textContent = `${reference} (${(got.version||versionCode).toUpperCase()}) · ${titleCase(cls)}${got.fallback ? " · (fallback source)" : ""}`;
        if(got.copyright){ copylineEl.textContent = got.copyright; }
      }catch(err){
        const ui = err._ui || {};
        showBanner("error", `${ui.user || "Could not load verse."} ${ui.hint ? "Hint: " + ui.hint : ""}`);
        console.error("Verse load failed:", ui.detail || err);
      } finally { setLoading(false); }
    }

    function restartSameVerse(){
      clearTimers();
      resetTypingArea(verseText, reference);
      categoryTitleEl.textContent=titleCase(actualCategory);
      const blindActive=blindToggleEl.checked; setBlindFaithUI(blindActive);
      if(blindActive){ showVerse(); startBlindPreviewThenHide(); } else { setTypingEnabled(true); showVerse(); }
    }

    // ======= Input handling =======
    inputEl.addEventListener("input", () => {
      const newVal = inputEl.value;
      const vtNorm = normalizeQuotes(verseText);
      const newNorm = normalizeQuotes(newVal);
      const prevNorm = normalizeQuotes(prevValue);

      if (blindToggleEl.checked && remainingEl.textContent.length > 0) {
        setTypingEnabled(false);
        inputEl.value = prevValue;
        return;
      }

      if (newVal.length > prevValue.length) {
        const added = newNorm.slice(prevNorm.length);
        for (let i = 0; i < added.length; i++) {
          const idx = prevNorm.length + i; const ch = added[i];
          totalKeystrokes++; if (ch !== vtNorm[idx]) errorKeystrokes++;
        }
      }
      prevValue = newVal;

      if (!started && newVal.length > 0) { started = true; startTime = performance.now(); }
      updateLiveMetrics();

      const blindActive = blindToggleEl.checked;
      const verseVisible = remainingEl.textContent.length > 0;
      if (!blindActive || verseVisible) {
        const targetNorm = vtNorm.substring(0, newNorm.length);
        if (newNorm === targetNorm) {
          typedEl.textContent = verseText.substring(0, newVal.length);
          remainingEl.textContent = verseText.substring(newVal.length);
          inputEl.style.color = "var(--ink)";
        } else inputEl.style.color = "var(--err)";
        if (newVal.length === verseText.length && newNorm === vtNorm) finishAttempt(false);
      } else {
        const targetNorm = vtNorm.substring(0, newNorm.length);
        inputEl.style.color = (newNorm === targetNorm) ? "var(--ink)" : "var(--err)";
      }
    });

    // ======= Buttons & shortcuts =======
    newVerseBtn.addEventListener("click", loadRandomVerseForSelection);
    restartBtn.addEventListener("click", restartSameVerse);
    categoryEl.addEventListener("change", loadRandomVerseForSelection);
    lengthEl.addEventListener("change", loadRandomVerseForSelection);
    versionEl.addEventListener("change", loadRandomVerseForSelection);
    blindToggleEl.addEventListener("change", () => {
      setBlindFaithUI(blindToggleEl.checked);
      loadRandomVerseForSelection();
    });
    previewSecEl.addEventListener("change", () => { getPreviewMs(); });
    peekSecEl.addEventListener("change", () => { getPeekMs(); syncPeekButtonLabel(); });
    peekBtn && peekBtn.addEventListener("click", handlePeek);
    finishBtn && finishBtn.addEventListener("click", () => finishAttempt(true));
    exportBtn.addEventListener("click", exportCSV);
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && (e.key === "Enter")) { e.preventDefault(); finishAttempt(true); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "p")) { e.preventDefault(); handlePeek(); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "r")) { e.preventDefault(); restartSameVerse(); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "m")) { e.preventDefault(); loadRandomVerseForSelection(); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "j")) {
        e.preventDefault();
        const modes = ['auto','light','dark'];
        const cur = localStorage.getItem(THEME_KEY) || 'auto';
        const idx = (modes.indexOf(cur)+1) % modes.length;
        applyTheme(modes[idx]);
      }
    });

    // ======= Init =======
    (async () => {
      initTheme();

      previewSecEl.value = localStorage.getItem("tof_preview_sec") ?? DEFAULT_PREVIEW_SEC;
      peekSecEl.value = localStorage.getItem("tof_peek_sec") ?? DEFAULT_PEEK_SEC;
      syncPeekButtonLabel();
      setBlindFaithUI(blindToggleEl.checked);

      categoryTitleEl.textContent=currentCategorySelectionLabel();

      try { const res = await fetch("http://127.0.0.1:8000/health", { cache:"no-store" }); if (!res.ok) throw new Error("Proxy offline"); }
      catch { showBanner("warn", "Proxy offline. KJV/WEB will fall back to public provider. Start FastAPI for FBV/ESV."); }
      finally { loadRandomVerseForSelection(); }
    })();
  </script>
</body>
</html>
