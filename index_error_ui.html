<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Type of Faith MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#faf8f5; --ink:#111; --muted:#555; --ok:#0a7a0a; --err:#b00020; --accent:#8b6b3b; --panel:#fff; --border:#eee; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg); color: var(--ink); margin: 24px; }
    h1 { margin: 0 0 8px; color: var(--accent); }
    h2 { margin: 8px 0 16px; font-weight: 600; color: var(--ink); }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
    select, button, label { font-size: 16px; }
    select, button { padding: 8px 10px; }
    button { cursor: pointer; border: 1px solid #ccc; background: white; border-radius: 6px; }
    button:active { transform: translateY(1px); }
    .toggle { display: inline-flex; gap: 8px; align-items: center; }
    #meta { font-size: 14px; color: var(--muted); margin-bottom: 4px; }
    #banner { font-size: 14px; color: var(--accent); margin: 6px 0 10px; padding: 6px 8px; border-radius: 6px; background: #fff7e6; display:none; }
    #verse { font-size: 20px; line-height: 1.6; margin-bottom: 6px; background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 16px; min-height: 3.5em; }
    #typed { color: var(--ok); }
    #remaining { color: var(--muted); }
    #hiddenMask { color: var(--muted); font-style: italic; }
    #input { width: 100%; font-size: 20px; padding: 10px 12px; border-radius: 8px; border: 1px solid #ddd; }
    .bf-controls { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    .right { margin-left: auto; }
    .panels { display: grid; gap: 12px; grid-template-columns: 1fr; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 12px; }
    .stat { font-variant-numeric: tabular-nums; }
    #status { font-size: 14px; color: var(--muted); }
    #result { font-size: 16px; }
    #bestStats { font-size: 14px; }
    #peekCount { font-weight: 600; }
    .hint { font-size: 12px; color: var(--muted); }
    .copyline { font-size: 12px; color: var(--muted); margin: 6px 0 8px; }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { text-align: left; padding: 8px; border-bottom: 1px solid var(--border); }
    th { background: #f3efe8; }
    @media (min-width: 1000px) { .panels { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <h1>Type of Faith MVP</h1>

  <div class="controls">
    <label>
      Category:
      <select id="category">
        <option value="all">All</option>
        <option value="anger">Anger</option>
        <option value="anxiety">Anxiety</option>
        <option value="courage">Courage</option>
        <option value="depression">Depression</option>
        <option value="doubt">Doubt</option>
        <option value="faith">Faith</option>
        <option value="fear">Fear</option>
        <option value="forgiveness">Forgiveness</option>
        <option value="healing">Healing</option>
        <option value="hope">Hope</option>
        <option value="jealousy">Jealousy</option>
        <option value="joy">Joy</option>
        <option value="loss">Loss</option>
        <option value="love">Love</option>
        <option value="patience">Patience</option>
        <option value="peace">Peace</option>
        <option value="pride">Pride</option>
        <option value="stress">Stress</option>
        <option value="temptation">Temptation</option>
        <option value="wisdom">Wisdom</option>
      </select>
    </label>

    <label>
      Verse length:
      <select id="length">
        <option value="any">Any</option>
        <option value="short">Short</option>
        <option value="medium">Medium</option>
        <option value="long">Long</option>
      </select>
    </label>

    <label>
      Version:
      <select id="version">
        <option value="KJV">KJV (bible-api.com)</option>
        <option value="WEB">WEB (World English Bible)</option>
        <option value="FBV">FBV (api.bible via proxy)</option>
        <option value="ESV">ESV (Crossway API via proxy)</option>
      </select>
    </label>

    <label class="toggle" title="Show verse briefly, then hide it so you type from memory">
      <input type="checkbox" id="blindToggle" />
      Blind Faith
    </label>

    <label class="toggle" title="Initial visible time before hiding (1–30s)">
      Preview (s):
      <input id="previewSec" type="number" min="1" max="30" step="1" style="width:72px" />
    </label>

    <label class="toggle" title="Peek reveal time (1–10s)">
      Peek (s):
      <input id="peekSec" type="number" min="1" max="10" step="1" style="width:72px" />
    </label>

    <button id="newVerseBtn" title="Ctrl+M">New Verse</button>
    <button id="restartBtn" title="Restart this verse (Ctrl+R)">Restart</button>
  </div>

  <!-- Actual category title of the fetched verse -->
  <h2 id="categoryTitle">All</h2>

  <div id="meta"></div>
  <div id="banner"></div>

  <div id="verse">
    <span id="typed"></span><span id="remaining"></span><span id="hiddenMask"></span>
  </div>

  <div class="copyline" id="copyline"></div>

  <!-- Blind Faith-only controls -->
  <div class="bf-controls" id="bfControls" style="display:none;">
    <button id="peekBtn" title="Reveal the verse for 5 seconds (Ctrl+P)">Peek Verse (5s)</button>
    <button id="finishBtn" title="Calculate your fairness score (Ctrl+Enter)">Finish Attempt</button>
    <span>Peeks used: <span id="peekCount">0</span></span>
    <span class="hint right">Shortcuts: Ctrl+P peek · Ctrl+Enter finish · Ctrl+R restart · Ctrl+M new</span>
  </div>

  <input id="input" placeholder="Start typing the verse here…" autocomplete="off" spellcheck="false" />

  <div class="panels">
    <div class="card">
      <strong>Live Metrics</strong>
      <div id="status" class="stat">WPM: 0 · Accuracy: 100% · Time: 0.0s</div>
    </div>
    <div class="card">
      <strong>Result</strong>
      <div id="result" class="stat">—</div>
    </div>
    <div class="card" style="grid-column: 1 / -1;">
      <strong>Best of Session</strong>
      <div id="bestStats" class="stat">
        Best WPM: — · Best Accuracy: — · Fastest Time: — · Best Fairness (Blind): —
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <div style="display:flex; align-items:center; gap:8px;">
      <strong>Session History</strong>
      <button id="exportBtn" class="right" title="Download CSV of attempts">Export CSV</button>
    </div>
    <div style="overflow:auto;">
      <table id="historyTable" aria-label="Session History">
        <thead>
          <tr>
            <th>Time</th>
            <th>Category</th>
            <th>Reference</th>
            <th>Mode</th>
            <th>Peeks</th>
            <th>Secs</th>
            <th>WPM</th>
            <th>Accuracy%</th>
            <th>Fairness%</th>
          </tr>
        </thead>
        <tbody id="historyBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // ------- Config -------
    const DEFAULT_PREVIEW_SEC = 10;
    const DEFAULT_PEEK_SEC = 5;
    const LEN_THRESHOLDS = { shortMax: 110, mediumMax: 230 };

    function getPreviewMs() {
      const n = clampInt(Number(previewSecEl.value || DEFAULT_PREVIEW_SEC), 1, 30);
      if (String(n) !== String(previewSecEl.value)) previewSecEl.value = n;
      localStorage.setItem("tof_preview_sec", String(n));
      return n * 1000;
    }
    function getPeekMs() {
      const n = clampInt(Number(peekSecEl.value || DEFAULT_PEEK_SEC), 1, 10);
      if (String(n) !== String(peekSecEl.value)) peekSecEl.value = n;
      localStorage.setItem("tof_peek_sec", String(n));
      return n * 1000;
    }
    function clampInt(n, min, max){ n = Math.floor(isFinite(n) ? n : min); return Math.min(max, Math.max(min, n)); }

    // Load saved values or defaults
    previewSecEl.value = localStorage.getItem("tof_preview_sec") ?? DEFAULT_PREVIEW_SEC;
    peekSecEl.value = localStorage.getItem("tof_peek_sec") ?? DEFAULT_PEEK_SEC;

    // Keep Peek button label in sync
    function syncPeekButtonLabel() {
      const secs = clampInt(Number(peekSecEl.value || DEFAULT_PEEK_SEC), 1, 10);
      if (peekBtn) peekBtn.textContent = `Peek Verse (${secs}s)`;
    }
    syncPeekButtonLabel();

    // Update storage/label when user edits
    previewSecEl.addEventListener("change", () => { getPreviewMs(); });
    peekSecEl.addEventListener("change", () => { getPeekMs(); syncPeekButtonLabel(); });


    // ------- Category → references (alphabetical categories) -------
    const VERSE_CATEGORIES = {
      anger: ["Ephesians 4:26", "Proverbs 15:1", "James 1:19-20", "Colossians 3:8"],
      anxiety: ["Philippians 4:6-7", "1 Peter 5:7", "Matthew 6:34", "Psalm 94:19"],
      courage: ["Joshua 1:9", "Psalm 27:1", "2 Timothy 1:7", "Deuteronomy 31:6"],
      depression: ["Psalm 34:17-18", "Psalm 42:11", "Isaiah 41:10", "Matthew 11:28"],
      doubt: ["James 1:6", "Mark 9:24", "Matthew 21:21", "John 20:27"],
      faith: ["Hebrews 11:1", "Proverbs 3:5-6", "Mark 11:24", "2 Corinthians 5:7"],
      fear: ["Isaiah 41:10", "2 Timothy 1:7", "Psalm 56:3", "Deuteronomy 31:6"],
      forgiveness: ["Ephesians 4:32", "Colossians 3:13", "Matthew 6:14", "Psalm 103:12"],
      healing: ["Jeremiah 30:17", "Isaiah 53:5", "James 5:14-15", "Psalm 147:3"],
      hope: ["Jeremiah 29:11", "Romans 15:13", "Psalm 42:5", "Isaiah 40:31"],
      jealousy: ["Proverbs 14:30", "James 3:16", "Galatians 5:26", "1 Corinthians 3:3"],
      joy: ["Nehemiah 8:10", "Psalm 16:11", "Philippians 4:4", "John 15:11"],
      loss: ["Psalm 34:18", "Matthew 5:4", "Revelation 21:4", "1 Thessalonians 4:13-14"],
      love: ["1 Corinthians 13:4-7", "John 13:34", "1 John 4:7", "Romans 12:10"],
      patience: ["Galatians 6:9", "Romans 12:12", "James 5:8", "Ecclesiastes 7:8"],
      peace: ["John 14:27", "Philippians 4:7", "Isaiah 26:3", "Colossians 3:15"],
      pride: ["Proverbs 16:18", "James 4:6", "1 Peter 5:5", "Proverbs 11:2"],
      stress: ["Matthew 11:28-30", "John 16:33", "Psalm 55:22", "Proverbs 12:25"],
      temptation: ["1 Corinthians 10:13", "Matthew 26:41", "James 1:12-14", "Hebrews 2:18"],
      wisdom: ["James 1:5", "Proverbs 1:7", "Proverbs 3:13", "Proverbs 4:7"]
    };
    const ALL_REFERENCES = Object.values(VERSE_CATEGORIES).flat();

    // Build reverse map: reference → category
    const REF_TO_CATEGORY = (() => {
      const map = {};
      const cats = Object.keys(VERSE_CATEGORIES).sort((a,b)=>a.localeCompare(b));
      for (const cat of cats) {
        for (const ref of VERSE_CATEGORIES[cat]) if (!map[ref]) map[ref] = cat;
      }
      return map;
    })();

    // ------- DOM refs -------
    const categoryEl = document.getElementById("category");
    const lengthEl = document.getElementById("length");
    const versionEl = document.getElementById("version");
    const blindToggleEl = document.getElementById("blindToggle");
    const categoryTitleEl = document.getElementById("categoryTitle");
    const newVerseBtn = document.getElementById("newVerseBtn");
    const restartBtn = document.getElementById("restartBtn");
    const metaEl = document.getElementById("meta");
    const bannerEl = document.getElementById("banner");
    const typedEl = document.getElementById("typed");
    const remainingEl = document.getElementById("remaining");
    const hiddenMaskEl = document.getElementById("hiddenMask");
    const inputEl = document.getElementById("input");
    const bfControlsEl = document.getElementById("bfControls");
    const peekBtn = document.getElementById("peekBtn");
    const finishBtn = document.getElementById("finishBtn");
    const peekCountEl = document.getElementById("peekCount");
    const statusEl = document.getElementById("status");
    const resultEl = document.getElementById("result");
    const bestStatsEl = document.getElementById("bestStats");
    const exportBtn = document.getElementById("exportBtn");
    const historyBody = document.getElementById("historyBody");
    const copylineEl = document.getElementById("copyline");
    const previewSecEl = document.getElementById("previewSec");
    const peekSecEl = document.getElementById("peekSec");

    // ------- State -------
    let verseText = "";
    let reference = "";
    let actualCategory = "All";
    let hideTimer = null, countdownTimer = null, peekTimer = null, peekCount = 0;

    // typing metrics
    let started = false, startTime = 0, finished = false;

    // keystroke-based accuracy
    let totalKeystrokes = 0, errorKeystrokes = 0, prevValue = "";

    // best-of-session
    let bestWPM = null, bestAccuracy = null, fastestTime = null, bestFairness = null;

    // session history
    const history = [];

    // ------- UI helpers -------
    function showBanner(type, message) {
      const el = bannerEl;
      el.textContent = message || "";
      el.style.display = message ? "block" : "none";
      el.style.color = (type === "error") ? "#b00020"
                    : (type === "warn")  ? "#8b6b3b"
                    : (type === "success") ? "#0a7a0a"
                    : "#555";
    }
    function setLoading(isLoading) {
      const btns = [newVerseBtn, restartBtn, peekBtn, finishBtn].filter(Boolean);
      btns.forEach(b => b.disabled = !!isLoading);
      inputEl.disabled = !!isLoading;
      if (isLoading) {
        metaEl.textContent = "Loading verse…";
        showBanner("info", "Contacting verse providers…");
      } else {
        if (/Contacting verse providers/.test(bannerEl.textContent)) showBanner("info", "");
      }
    }
    function withTimeout(ms) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), ms);
      return { signal: ctrl.signal, cancel: () => clearTimeout(t) };
    }
    function classifyError(err, res=null, bodyText="") {
      const detail = (err && err.message) ? err.message : "";
      if (!res) {
        return { code: "NETWORK", user: "Cannot reach the verse server.", hint: "If using FBV/ESV, start FastAPI (uvicorn server:app --reload --port 8000).", detail };
      }
      const s = res.status;
      if (s === 401) return { code: "UNAUTHORIZED", user: "The verse service rejected credentials.", hint: "Check API keys in .env / environment.", detail: bodyText };
      if (s === 403) return { code: "FORBIDDEN", user: "This translation requires publisher permission.", hint: "Try KJV/WEB or an allowed version like FBV.", detail: bodyText };
      if (s === 404) return { code: "NOT_FOUND", user: "No verse found for that reference.", hint: "Try a different verse or category.", detail: bodyText };
      if (s === 502 || s === 503 || s === 504) return { code: "UPSTREAM", user: "Upstream provider unavailable.", hint: "Wait a moment and try again.", detail: bodyText };
      return { code: "SERVER", user: "The verse server hit an error.", hint: "Try again or switch to KJV/WEB.", detail: bodyText };
    }

    // ------- Misc helpers -------
    const titleCase = s => s.replace(/\b\w/g, c => c.toUpperCase());
    const currentCategorySelectionLabel = () => (categoryEl.value === "all" ? "All" : titleCase(categoryEl.value));

    function getRandomRefAndCategory(category) {
      if (category && category !== "all") {
        const list = VERSE_CATEGORIES[category] || [];
        const ref = list[Math.floor(Math.random() * list.length)];
        return { ref, cat: category };
      }
      const ref = ALL_REFERENCES[Math.floor(Math.random() * ALL_REFERENCES.length)];
      const cat = REF_TO_CATEGORY[ref] || "all";
      return { ref, cat };
    }
    function classifyLengthByChars(text) {
      const len = text.trim().length;
      if (len <= LEN_THRESHOLDS.shortMax) return "short";
      if (len <= LEN_THRESHOLDS.mediumMax) return "medium";
      return "long";
    }
    function normalizeQuotes(s) {
      return (s || "")
        .replace(/[‘’‚‛]/g, "'")
        .replace(/[“”„‟]/g, '"');
    }
    function normalize(s){ return s.toLowerCase().replace(/[^a-z0-9\s]/g,"").replace(/\s+/g," ").trim(); }
    function levenshtein(a,b){
      const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>new Array(n+1));
      for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j;
      for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const c=a[i-1]===b[j-1]?0:1;
        dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+c); } }
      return dp[m][n];
    }
    function computeFairnessScore(groundTruth,attempt){
      const g=normalize(groundTruth), t=normalize(attempt);
      if(!g.length) return {scorePct:0,distance:0,baseLen:0};
      const dist=levenshtein(g,t); const score=Math.max(0,1-dist/g.length);
      return {scorePct:Math.round(score*100),distance:dist,baseLen:g.length};
    }
    function setTypingEnabled(on) {
      // Use readOnly so the field keeps focus/appearance but won’t accept input
      inputEl.readOnly = !on;
      inputEl.placeholder = on
          ? "Start typing the verse here…"
          : "Typing disabled while verse is visible (Blind Faith)";
      }


    // ---- Provider calls ----
    async function fetchViaProxy(ref, versionCode) {
      const base = "http://127.0.0.1:8000";
      const url = `${base}/verse?ref=${encodeURIComponent(ref)}&version=${encodeURIComponent(versionCode)}`;
      const { signal, cancel } = withTimeout(9000);
      try {
        const res = await fetch(url, { signal });
        const text = await res.text();
        if (!res.ok) throw { __http: true, res, text };
        return JSON.parse(text);
      } catch (e) {
        if (e.__http) {
          const c = classifyError(null, e.res, e.text);
          const err = new Error(c.user); err._ui = c; throw err;
        } else {
          const c = classifyError(e);
          const err = new Error(c.user); err._ui = c; throw err;
        }
      } finally { cancel(); }
    }
    async function fetchViaBibleApi(ref, versionCode) {
      const t = (versionCode || "KJV").toLowerCase();
      const url = `https://bible-api.com/${encodeURIComponent(ref)}?translation=${encodeURIComponent(t)}`;
      const { signal, cancel } = withTimeout(9000);
      try {
        const res = await fetch(url, { signal });
        const text = await res.text();
        if (!res.ok) throw { __http: true, res, text };
        const data = JSON.parse(text);
        const verseText = Array.isArray(data.verses) && data.verses.length
          ? data.verses.map(v => v.text.trim()).join(" ")
          : (data.text || "");
        return {
          reference: data.reference || ref,
          text: verseText.replace(/\s+/g, " ").trim(),
          version: (versionCode || "KJV").toUpperCase(),
          fallback: true
        };
      } catch (e) {
        if (e.__http) {
          const c = classifyError(null, e.res, e.text);
          const err = new Error(c.user); err._ui = c; throw err;
        } else {
          const c = classifyError(e);
          const err = new Error(c.user); err._ui = c; throw err;
        }
      } finally { cancel(); }
    }
    async function fetchVerseUnified(ref, versionCode) {
      try {
        return await fetchViaProxy(ref, versionCode);
      } catch (e) {
        const info = e._ui || {};
        const pub = ["KJV","WEB"];
        if (pub.includes(versionCode)) {
          showBanner("warn", `${info.user || "Proxy unavailable."} Falling back to public provider for ${versionCode}…`);
          try {
            return await fetchViaBibleApi(ref, versionCode);
          } catch (e2) {
            const info2 = e2._ui || {};
            showBanner("error", `${info2.user || "Failed to fetch verse."} ${info2.hint ? "Hint: "+info2.hint : ""}`);
            throw e2;
          }
        }
        showBanner("error", `${info.user || "Verse proxy error."} ${info.hint ? "Hint: "+info.hint : ""}`);
        throw e;
      }
    }

    function clearTimers() {
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
      if (peekTimer) { clearTimeout(peekTimer); peekTimer = null; }
      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    }

    function resetTypingArea(text, ref) {
      verseText = text;
      reference = ref;
      typedEl.textContent = "";
      remainingEl.textContent = verseText;
      hiddenMaskEl.textContent = "";
      inputEl.value = "";
      inputEl.style.color = "black";
      bannerEl.textContent = "";
      resultEl.textContent = "—";
      copylineEl.textContent = "";
      peekCount = 0; peekCountEl.textContent = "0";
      started = false; startTime = 0; finished = false;
      totalKeystrokes = 0; errorKeystrokes = 0; prevValue = "";
      updateLiveMetrics();
      inputEl.focus();
      setTypingEnabled(true);  
    }

    function setBlindFaithUI(active) { bfControlsEl.style.display = active ? "flex" : "none"; previewSecEl.disabled = !active;peekSecEl.disabled = !active;}

    function startBlindPreviewThenHide() {
      let total = getPreviewMs();
      let msLeft = total;
      showBanner("info", `Blind Faith: Memorise the verse… Hiding in ${(msLeft/1000).toFixed(0)}s`);
      countdownTimer = setInterval(() => {
          msLeft -= 1000;
          if (msLeft <= 0) { clearInterval(countdownTimer); countdownTimer = null; }
          else { showBanner("info", `Blind Faith: Memorise the verse… Hiding in ${(msLeft/1000).toFixed(0)}s`); }
      }, 1000);
      hideTimer = setTimeout(() => { hideVerse(); showBanner("info", "Blind Faith: Type from memory. Use Peek if needed."); hideTimer = null; }, total);
    }

    function showVerse() { hiddenMaskEl.textContent = ""; typedEl.textContent = ""; remainingEl.textContent = verseText; if (blindToggleEl.checked) setTypingEnabled(false);}  // BLOCK typing while visible
    function hideVerse() { typedEl.textContent = ""; remainingEl.textContent = ""; hiddenMaskEl.textContent = "— Verse hidden — type from memory —"; if (blindToggleEl.checked) { setTypingEnabled(true); inputEl.focus(); }}  // ENABLE typing
    function handlePeek() {
      if (peekTimer) return;
      peekCount += 1; peekCountEl.textContent = String(peekCount);
      showVerse();
      const ms = getPeekMs();
      peekTimer = setTimeout(() => { hideVerse(); peekTimer = null; }, ms);
    }
    // --- Live metrics ---
    function getElapsedSeconds(){ return !started?0:(performance.now()-startTime)/1000; }
    function computeLiveMetrics(currentTyped){
      const elapsedSec=getElapsedSeconds(), minutes=elapsedSec/60;
      const vtNorm = normalizeQuotes(verseText);
      const ctNorm = normalizeQuotes(currentTyped||"");
      let correctChars=0;
      for(let i=0;i<ctNorm.length;i++){ if(ctNorm[i]===vtNorm[i]) correctChars++; }
      const grossWPM=minutes>0?((correctChars/5)/minutes):0;
      const acc= totalKeystrokes>0? Math.max(0,1-(errorKeystrokes/totalKeystrokes)) : 1;
      return { wpm: Math.round(grossWPM), accuracy: Math.round(acc*100), timeSec: elapsedSec };
    }
    function updateLiveMetrics(){
      const { wpm, accuracy, timeSec } = computeLiveMetrics(inputEl.value||"");
      statusEl.textContent = `WPM: ${wpm} · Accuracy: ${accuracy}% · Time: ${timeSec.toFixed(1)}s`;
    }

    function addHistoryRow(entry){
      const tr=document.createElement("tr");
      const cells=[entry.timeLocal,entry.category,entry.reference,entry.mode,String(entry.peeks),entry.seconds.toFixed(2),String(entry.wpm),String(entry.accuracyPct),(entry.fairnessPct!=null?String(entry.fairnessPct):"—")];
      for(const c of cells){ const td=document.createElement("td"); td.textContent=c; tr.appendChild(td); }
      historyBody.prepend(tr);
    }

    function exportCSV(){
      const header=["Time","Category","Reference","Mode","Peeks","Seconds","WPM","AccuracyPct","FairnessPct"];
      const rows=[header.join(",")];
      for(const e of history){
        const row=[`"${e.timeLocal.replace(/"/g,'""')}"`,`"${e.category}"`,`"${e.reference.replace(/"/g,'""')}"`,`"${e.mode}"`,e.peeks,e.seconds.toFixed(2),e.wpm,e.accuracyPct,(e.fairnessPct!=null?e.fairnessPct:"")];
        rows.push(row.join(","));
      }
      const blob=new Blob([rows.join("\n")],{type:"text/csv;charset=utf-8"});
      const url=URL.createObjectURL(blob); const a=document.createElement("a");
      a.href=url; a.download="type-of-faith-session.csv"; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    }

    function finishAttempt(isBlindFinish=false){
      if(finished) return; finished=true;
      const attempt=inputEl.value||""; const elapsedSec=getElapsedSeconds(); const minutes=elapsedSec/60;
      let correctChars=0; const vtNorm=normalizeQuotes(verseText); const atNorm=normalizeQuotes(attempt);
      for(let i=0;i<atNorm.length;i++){ if(atNorm[i]===vtNorm[i]) correctChars++; }
      const grossWPM=minutes>0?Math.round(((correctChars/5)/minutes)):0;
      const acc= totalKeystrokes>0? Math.max(0,1-(errorKeystrokes/totalKeystrokes)) : 1;
      const accuracyPct=Math.round(acc*100);

      let result=`Ref: ${reference} · Time: ${elapsedSec.toFixed(2)}s · WPM: ${grossWPM} · Accuracy: ${accuracyPct}%`;
      let fairnessPct=null;
      if(blindToggleEl.checked||isBlindFinish){
        const {scorePct}=computeFairnessScore(verseText,attempt); fairnessPct=scorePct;
        result+=` · Fairness: ${fairnessPct}% · Peeks: ${peekCount}`;
        if(bestFairness===null||fairnessPct>bestFairness) bestFairness=fairnessPct;
      }
      resultEl.textContent=result;

      if(bestWPM===null||grossWPM>bestWPM) bestWPM=grossWPM;
      if(bestAccuracy===null||accuracyPct>bestAccuracy) bestAccuracy=accuracyPct;
      if(fastestTime===null||elapsedSec<fastestTime) fastestTime=elapsedSec;
      bestStatsEl.textContent=`Best WPM: ${bestWPM??"—"} · Best Accuracy: ${bestAccuracy??"—"}% · Fastest Time: ${fastestTime?fastestTime.toFixed(2)+"s":"—"} · Best Fairness (Blind): ${bestFairness??"—"}%`;

      const entry={ timeLocal:new Date().toLocaleString(), category:titleCase(actualCategory), reference, mode:(blindToggleEl.checked?"Blind":"Normal"), peeks:peekCount, seconds:elapsedSec, wpm:grossWPM, accuracyPct, fairnessPct };
      history.push(entry); addHistoryRow(entry);
    }

    // Try to get a verse matching length; return {reference,text,cat}
    async function fetchVerseMatchingLength(category, lengthPref, versionCode){
      if(lengthPref==="any"){
        const pick=getRandomRefAndCategory(category);
        const got=await fetchVerseUnified(pick.ref, versionCode);
        return { reference: got.reference, text: got.text, cat: REF_TO_CATEGORY[pick.ref] || category, copyright: got.copyright, version: got.version };
      }
      const MAX_TRIES=8; let last=null;
      for(let i=0;i<MAX_TRIES;i++){
        const pick=getRandomRefAndCategory(category);
        const got=await fetchVerseUnified(pick.ref, versionCode);
        const cls=classifyLengthByChars(got.text);
        last={ reference: got.reference, text: got.text, cat: REF_TO_CATEGORY[pick.ref] || category, copyright: got.copyright, version: got.version };
        if(cls===lengthPref) return last;
      }
      return last;
    }

    async function loadRandomVerseForSelection(){
      clearTimers();
      setLoading(true);
      const category=categoryEl.value;
      const lenPref=lengthEl.value;
      const versionCode=(versionEl.value||"KJV").toUpperCase();
      metaEl.textContent="Loading verse…";
      copylineEl.textContent="";
      categoryTitleEl.textContent=currentCategorySelectionLabel();

      try{
        const got=await fetchVerseMatchingLength(category,lenPref,versionCode);
        if(!got||!got.text) throw new Error("Empty verse text");
        showBanner("success","Verse loaded. Happy typing!");
        resetTypingArea(got.text, got.reference);
        actualCategory=got.cat||category;
        categoryTitleEl.textContent=titleCase(actualCategory);

        const blindActive=blindToggleEl.checked;
        setBlindFaithUI(blindActive);
        if(blindActive){ showVerse(); startBlindPreviewThenHide(); } else { setTypingEnabled(true); showVerse(); bannerEl.textContent=""; }

        const cls=classifyLengthByChars(got.text);
        metaEl.textContent = `${reference} (${(got.version||versionCode).toUpperCase()}) · ${titleCase(cls)}${got.fallback ? " · (fallback source)" : ""}`;
        if(got.copyright){ copylineEl.textContent = got.copyright; }
      }catch(err){
        const ui = err._ui || {};
        showBanner("error", `${ui.user || "Could not load verse."} ${ui.hint ? "Hint: " + ui.hint : ""}`);
        console.error("Verse load failed:", ui.detail || err);
        // keep UI usable, no hard retry here
      } finally {
        setLoading(false);
      }
    }

    function restartSameVerse(){
      clearTimers();
      resetTypingArea(verseText, reference);
      categoryTitleEl.textContent=titleCase(actualCategory);
      const blindActive=blindToggleEl.checked; setBlindFaithUI(blindActive);
      if(blindActive){ showVerse(); startBlindPreviewThenHide(); } else { setTypingEnabled(true); showVerse(); }
    }

    // Typing logic + keystroke accuracy counting (quote-normalized)
    inputEl.addEventListener("input", () => {
      const newVal = inputEl.value;

      const vtNorm = normalizeQuotes(verseText);
      const newNorm = normalizeQuotes(newVal);
      const prevNorm = normalizeQuotes(prevValue);

      // If we're in Blind Faith *and* the verse is currently visible, ignore input
      if (blindToggleEl.checked && remainingEl.textContent.length > 0) {
        // Just in case readOnly was removed by the browser, reset it:
        setTypingEnabled(false);
        inputEl.value = prevValue; // prevent accidental edits
        return;
    }

      // Count keystrokes/errors for inserted chars only (compare normalized)
      if (newVal.length > prevValue.length) {
        const added = newNorm.slice(prevNorm.length);
        for (let i = 0; i < added.length; i++) {
          const idx = prevNorm.length + i;
          const ch = added[i];
          totalKeystrokes++;
          if (ch !== vtNorm[idx]) errorKeystrokes++;
        }
      }
      prevValue = newVal;

      if (!started && newVal.length > 0) { started = true; startTime = performance.now(); }
      updateLiveMetrics();

      const blindActive = blindToggleEl.checked;
      const verseVisible = remainingEl.textContent.length > 0;

      if (!blindActive || verseVisible) {
        const targetNorm = vtNorm.substring(0, newNorm.length);
        if (newNorm === targetNorm) {
          typedEl.textContent = verseText.substring(0, newVal.length);
          remainingEl.textContent = verseText.substring(newVal.length);
          inputEl.style.color = "black";
        } else {
          inputEl.style.color = "var(--err)";
        }
        if (newVal.length === verseText.length && newNorm === vtNorm) { finishAttempt(false); }
      } else {
        const targetNorm = vtNorm.substring(0, newNorm.length);
        inputEl.style.color = (newNorm === targetNorm) ? "black" : "var(--err)";
      }
    });

    // Buttons
    newVerseBtn.addEventListener("click", loadRandomVerseForSelection);
    restartBtn.addEventListener("click", restartSameVerse);
    categoryEl.addEventListener("change", loadRandomVerseForSelection);
    lengthEl.addEventListener("change", loadRandomVerseForSelection);
    versionEl.addEventListener("change", loadRandomVerseForSelection);
    blindToggleEl.addEventListener("change", loadRandomVerseForSelection);
    peekBtn && peekBtn.addEventListener("click", handlePeek);
    finishBtn && finishBtn.addEventListener("click", () => finishAttempt(true));
    exportBtn.addEventListener("click", exportCSV);

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && (e.key === "Enter")) { e.preventDefault(); finishAttempt(true); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "p")) { e.preventDefault(); handlePeek(); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "r")) { e.preventDefault(); restartSameVerse(); }
      else if (e.ctrlKey && (e.key.toLowerCase() === "m")) { e.preventDefault(); loadRandomVerseForSelection(); }
    });

    // Initial load + proxy status hint
    categoryTitleEl.textContent=currentCategorySelectionLabel();
    (async () => {
      try {
        const res = await fetch("http://127.0.0.1:8000/health", { cache: "no-store" });
        if (!res.ok) throw new Error("Proxy offline");
      } catch {
        showBanner("warn", "Proxy offline. KJV/WEB will fall back to public provider. Start FastAPI for FBV/ESV.");
      } finally {
        loadRandomVerseForSelection();
      }
    })();
  </script>
</body>
</html>
